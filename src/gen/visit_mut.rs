// THIS FILE IS AUTOMATICALLY GENERATED; DO NOT EDIT

//! AST walker. Each overridden visit method has full control over what
//! happens with its node, it can do its own traversal of the node's children,
//! call `visit::walk_*` to apply the default traversal algorithm, or prevent
//! deeper traversal by doing nothing.

#![cfg_attr(rustfmt, rustfmt_skip)]

#![cfg_attr(feature = "cargo-clippy", allow(match_same_arms))]

use *;
use proc_macro2::Span;
use gen::helper::visit_mut::*;


#[cfg(feature = "full")]
macro_rules! full {
    ($e:expr) => { $e }
}

#[cfg(not(feature = "full"))]
macro_rules! full {
    ($e:expr) => { unreachable!() }
}


/// Each method of the VisitorMut trait is a hook to be potentially
/// overridden.  Each method's default implementation recursively visits
/// the substructure of the input via the corresponding `walk` method;
/// e.g. the `visit_mod` method by default calls `visit::walk_mod`.
///
/// If you want to ensure that your code handles every variant
/// explicitly, you need to override each method.  (And you also need
/// to monitor future changes to `VisitorMut` in case a new method with a
/// new default implementation gets introduced.)
pub trait VisitorMut {

fn visit_abi_mut(&mut self, i: &mut Abi) { visit_abi_mut(self, i) }

fn visit_abi_kind_mut(&mut self, i: &mut AbiKind) { visit_abi_kind_mut(self, i) }

fn visit_angle_bracketed_generic_arguments_mut(&mut self, i: &mut AngleBracketedGenericArguments) { visit_angle_bracketed_generic_arguments_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_arg_captured_mut(&mut self, i: &mut ArgCaptured) { visit_arg_captured_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_arg_self_mut(&mut self, i: &mut ArgSelf) { visit_arg_self_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_arg_self_ref_mut(&mut self, i: &mut ArgSelfRef) { visit_arg_self_ref_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_arm_mut(&mut self, i: &mut Arm) { visit_arm_mut(self, i) }

fn visit_attr_style_mut(&mut self, i: &mut AttrStyle) { visit_attr_style_mut(self, i) }

fn visit_attribute_mut(&mut self, i: &mut Attribute) { visit_attribute_mut(self, i) }

fn visit_bare_fn_arg_mut(&mut self, i: &mut BareFnArg) { visit_bare_fn_arg_mut(self, i) }

fn visit_bare_fn_arg_name_mut(&mut self, i: &mut BareFnArgName) { visit_bare_fn_arg_name_mut(self, i) }

fn visit_bare_fn_type_mut(&mut self, i: &mut BareFnType) { visit_bare_fn_type_mut(self, i) }

fn visit_bin_op_mut(&mut self, i: &mut BinOp) { visit_bin_op_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_binding_mode_mut(&mut self, i: &mut BindingMode) { visit_binding_mode_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_block_mut(&mut self, i: &mut Block) { visit_block_mut(self, i) }

fn visit_body_mut(&mut self, i: &mut Body) { visit_body_mut(self, i) }

fn visit_body_enum_mut(&mut self, i: &mut BodyEnum) { visit_body_enum_mut(self, i) }

fn visit_body_struct_mut(&mut self, i: &mut BodyStruct) { visit_body_struct_mut(self, i) }

fn visit_bound_lifetimes_mut(&mut self, i: &mut BoundLifetimes) { visit_bound_lifetimes_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_capture_by_mut(&mut self, i: &mut CaptureBy) { visit_capture_by_mut(self, i) }

fn visit_const_param_mut(&mut self, i: &mut ConstParam) { visit_const_param_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_constness_mut(&mut self, i: &mut Constness) { visit_constness_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_defaultness_mut(&mut self, i: &mut Defaultness) { visit_defaultness_mut(self, i) }

fn visit_derive_input_mut(&mut self, i: &mut DeriveInput) { visit_derive_input_mut(self, i) }

fn visit_expr_mut(&mut self, i: &mut Expr) { visit_expr_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_addr_of_mut(&mut self, i: &mut ExprAddrOf) { visit_expr_addr_of_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_array_mut(&mut self, i: &mut ExprArray) { visit_expr_array_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_assign_mut(&mut self, i: &mut ExprAssign) { visit_expr_assign_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_assign_op_mut(&mut self, i: &mut ExprAssignOp) { visit_expr_assign_op_mut(self, i) }

fn visit_expr_binary_mut(&mut self, i: &mut ExprBinary) { visit_expr_binary_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_block_mut(&mut self, i: &mut ExprBlock) { visit_expr_block_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_box_mut(&mut self, i: &mut ExprBox) { visit_expr_box_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_break_mut(&mut self, i: &mut ExprBreak) { visit_expr_break_mut(self, i) }

fn visit_expr_call_mut(&mut self, i: &mut ExprCall) { visit_expr_call_mut(self, i) }

fn visit_expr_cast_mut(&mut self, i: &mut ExprCast) { visit_expr_cast_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_catch_mut(&mut self, i: &mut ExprCatch) { visit_expr_catch_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_closure_mut(&mut self, i: &mut ExprClosure) { visit_expr_closure_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_continue_mut(&mut self, i: &mut ExprContinue) { visit_expr_continue_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_field_mut(&mut self, i: &mut ExprField) { visit_expr_field_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_for_loop_mut(&mut self, i: &mut ExprForLoop) { visit_expr_for_loop_mut(self, i) }

fn visit_expr_group_mut(&mut self, i: &mut ExprGroup) { visit_expr_group_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_if_mut(&mut self, i: &mut ExprIf) { visit_expr_if_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_if_let_mut(&mut self, i: &mut ExprIfLet) { visit_expr_if_let_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_in_place_mut(&mut self, i: &mut ExprInPlace) { visit_expr_in_place_mut(self, i) }

fn visit_expr_index_mut(&mut self, i: &mut ExprIndex) { visit_expr_index_mut(self, i) }

fn visit_expr_kind_mut(&mut self, i: &mut ExprKind) { visit_expr_kind_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_loop_mut(&mut self, i: &mut ExprLoop) { visit_expr_loop_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_match_mut(&mut self, i: &mut ExprMatch) { visit_expr_match_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_method_call_mut(&mut self, i: &mut ExprMethodCall) { visit_expr_method_call_mut(self, i) }

fn visit_expr_paren_mut(&mut self, i: &mut ExprParen) { visit_expr_paren_mut(self, i) }

fn visit_expr_path_mut(&mut self, i: &mut ExprPath) { visit_expr_path_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_range_mut(&mut self, i: &mut ExprRange) { visit_expr_range_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_repeat_mut(&mut self, i: &mut ExprRepeat) { visit_expr_repeat_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_ret_mut(&mut self, i: &mut ExprRet) { visit_expr_ret_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_struct_mut(&mut self, i: &mut ExprStruct) { visit_expr_struct_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_try_mut(&mut self, i: &mut ExprTry) { visit_expr_try_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_tuple_mut(&mut self, i: &mut ExprTuple) { visit_expr_tuple_mut(self, i) }

fn visit_expr_type_mut(&mut self, i: &mut ExprType) { visit_expr_type_mut(self, i) }

fn visit_expr_unary_mut(&mut self, i: &mut ExprUnary) { visit_expr_unary_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_unsafe_mut(&mut self, i: &mut ExprUnsafe) { visit_expr_unsafe_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_while_mut(&mut self, i: &mut ExprWhile) { visit_expr_while_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_while_let_mut(&mut self, i: &mut ExprWhileLet) { visit_expr_while_let_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_yield_mut(&mut self, i: &mut ExprYield) { visit_expr_yield_mut(self, i) }

fn visit_field_mut(&mut self, i: &mut Field) { visit_field_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_field_pat_mut(&mut self, i: &mut FieldPat) { visit_field_pat_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_field_value_mut(&mut self, i: &mut FieldValue) { visit_field_value_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_file_mut(&mut self, i: &mut File) { visit_file_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_fn_arg_mut(&mut self, i: &mut FnArg) { visit_fn_arg_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_fn_decl_mut(&mut self, i: &mut FnDecl) { visit_fn_decl_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_foreign_item_mut(&mut self, i: &mut ForeignItem) { visit_foreign_item_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_foreign_item_fn_mut(&mut self, i: &mut ForeignItemFn) { visit_foreign_item_fn_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_foreign_item_static_mut(&mut self, i: &mut ForeignItemStatic) { visit_foreign_item_static_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_foreign_item_type_mut(&mut self, i: &mut ForeignItemType) { visit_foreign_item_type_mut(self, i) }

fn visit_generic_argument_mut(&mut self, i: &mut GenericArgument) { visit_generic_argument_mut(self, i) }

fn visit_generic_param_mut(&mut self, i: &mut GenericParam) { visit_generic_param_mut(self, i) }

fn visit_generics_mut(&mut self, i: &mut Generics) { visit_generics_mut(self, i) }

fn visit_ident_mut(&mut self, i: &mut Ident) { visit_ident_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_impl_item_mut(&mut self, i: &mut ImplItem) { visit_impl_item_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_impl_item_const_mut(&mut self, i: &mut ImplItemConst) { visit_impl_item_const_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_impl_item_macro_mut(&mut self, i: &mut ImplItemMacro) { visit_impl_item_macro_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_impl_item_method_mut(&mut self, i: &mut ImplItemMethod) { visit_impl_item_method_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_impl_item_type_mut(&mut self, i: &mut ImplItemType) { visit_impl_item_type_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_impl_polarity_mut(&mut self, i: &mut ImplPolarity) { visit_impl_polarity_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_in_place_kind_mut(&mut self, i: &mut InPlaceKind) { visit_in_place_kind_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_index_mut(&mut self, i: &mut Index) { visit_index_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_mut(&mut self, i: &mut Item) { visit_item_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_const_mut(&mut self, i: &mut ItemConst) { visit_item_const_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_default_impl_mut(&mut self, i: &mut ItemDefaultImpl) { visit_item_default_impl_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_enum_mut(&mut self, i: &mut ItemEnum) { visit_item_enum_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_extern_crate_mut(&mut self, i: &mut ItemExternCrate) { visit_item_extern_crate_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_fn_mut(&mut self, i: &mut ItemFn) { visit_item_fn_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_foreign_mod_mut(&mut self, i: &mut ItemForeignMod) { visit_item_foreign_mod_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_impl_mut(&mut self, i: &mut ItemImpl) { visit_item_impl_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_macro_mut(&mut self, i: &mut ItemMacro) { visit_item_macro_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_macro2_mut(&mut self, i: &mut ItemMacro2) { visit_item_macro2_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_mod_mut(&mut self, i: &mut ItemMod) { visit_item_mod_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_static_mut(&mut self, i: &mut ItemStatic) { visit_item_static_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_struct_mut(&mut self, i: &mut ItemStruct) { visit_item_struct_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_trait_mut(&mut self, i: &mut ItemTrait) { visit_item_trait_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_type_mut(&mut self, i: &mut ItemType) { visit_item_type_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_union_mut(&mut self, i: &mut ItemUnion) { visit_item_union_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_use_mut(&mut self, i: &mut ItemUse) { visit_item_use_mut(self, i) }

fn visit_lifetime_mut(&mut self, i: &mut Lifetime) { visit_lifetime_mut(self, i) }

fn visit_lifetime_def_mut(&mut self, i: &mut LifetimeDef) { visit_lifetime_def_mut(self, i) }

fn visit_lit_mut(&mut self, i: &mut Lit) { visit_lit_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_local_mut(&mut self, i: &mut Local) { visit_local_mut(self, i) }

fn visit_macro_mut(&mut self, i: &mut Macro) { visit_macro_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_member_mut(&mut self, i: &mut Member) { visit_member_mut(self, i) }

fn visit_meta_item_mut(&mut self, i: &mut MetaItem) { visit_meta_item_mut(self, i) }

fn visit_meta_item_list_mut(&mut self, i: &mut MetaItemList) { visit_meta_item_list_mut(self, i) }

fn visit_meta_name_value_mut(&mut self, i: &mut MetaNameValue) { visit_meta_name_value_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_method_sig_mut(&mut self, i: &mut MethodSig) { visit_method_sig_mut(self, i) }

fn visit_mut_type_mut(&mut self, i: &mut MutType) { visit_mut_type_mut(self, i) }

fn visit_mutability_mut(&mut self, i: &mut Mutability) { visit_mutability_mut(self, i) }

fn visit_nested_meta_item_mut(&mut self, i: &mut NestedMetaItem) { visit_nested_meta_item_mut(self, i) }

fn visit_parenthesized_generic_arguments_mut(&mut self, i: &mut ParenthesizedGenericArguments) { visit_parenthesized_generic_arguments_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_mut(&mut self, i: &mut Pat) { visit_pat_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_box_mut(&mut self, i: &mut PatBox) { visit_pat_box_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_ident_mut(&mut self, i: &mut PatIdent) { visit_pat_ident_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_lit_mut(&mut self, i: &mut PatLit) { visit_pat_lit_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_path_mut(&mut self, i: &mut PatPath) { visit_pat_path_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_range_mut(&mut self, i: &mut PatRange) { visit_pat_range_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_ref_mut(&mut self, i: &mut PatRef) { visit_pat_ref_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_slice_mut(&mut self, i: &mut PatSlice) { visit_pat_slice_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_struct_mut(&mut self, i: &mut PatStruct) { visit_pat_struct_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_tuple_mut(&mut self, i: &mut PatTuple) { visit_pat_tuple_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_tuple_struct_mut(&mut self, i: &mut PatTupleStruct) { visit_pat_tuple_struct_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_wild_mut(&mut self, i: &mut PatWild) { visit_pat_wild_mut(self, i) }

fn visit_path_mut(&mut self, i: &mut Path) { visit_path_mut(self, i) }

fn visit_path_arguments_mut(&mut self, i: &mut PathArguments) { visit_path_arguments_mut(self, i) }

fn visit_path_segment_mut(&mut self, i: &mut PathSegment) { visit_path_segment_mut(self, i) }

fn visit_poly_trait_ref_mut(&mut self, i: &mut PolyTraitRef) { visit_poly_trait_ref_mut(self, i) }

fn visit_qself_mut(&mut self, i: &mut QSelf) { visit_qself_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_range_limits_mut(&mut self, i: &mut RangeLimits) { visit_range_limits_mut(self, i) }

fn visit_return_type_mut(&mut self, i: &mut ReturnType) { visit_return_type_mut(self, i) }

fn visit_span_mut(&mut self, i: &mut Span) { visit_span_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_stmt_mut(&mut self, i: &mut Stmt) { visit_stmt_mut(self, i) }

fn visit_trait_bound_modifier_mut(&mut self, i: &mut TraitBoundModifier) { visit_trait_bound_modifier_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_trait_item_mut(&mut self, i: &mut TraitItem) { visit_trait_item_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_trait_item_const_mut(&mut self, i: &mut TraitItemConst) { visit_trait_item_const_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_trait_item_macro_mut(&mut self, i: &mut TraitItemMacro) { visit_trait_item_macro_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_trait_item_method_mut(&mut self, i: &mut TraitItemMethod) { visit_trait_item_method_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_trait_item_type_mut(&mut self, i: &mut TraitItemType) { visit_trait_item_type_mut(self, i) }

fn visit_type_mut(&mut self, i: &mut Type) { visit_type_mut(self, i) }

fn visit_type_array_mut(&mut self, i: &mut TypeArray) { visit_type_array_mut(self, i) }

fn visit_type_bare_fn_mut(&mut self, i: &mut TypeBareFn) { visit_type_bare_fn_mut(self, i) }

fn visit_type_binding_mut(&mut self, i: &mut TypeBinding) { visit_type_binding_mut(self, i) }

fn visit_type_group_mut(&mut self, i: &mut TypeGroup) { visit_type_group_mut(self, i) }

fn visit_type_impl_trait_mut(&mut self, i: &mut TypeImplTrait) { visit_type_impl_trait_mut(self, i) }

fn visit_type_infer_mut(&mut self, i: &mut TypeInfer) { visit_type_infer_mut(self, i) }

fn visit_type_never_mut(&mut self, i: &mut TypeNever) { visit_type_never_mut(self, i) }

fn visit_type_param_mut(&mut self, i: &mut TypeParam) { visit_type_param_mut(self, i) }

fn visit_type_param_bound_mut(&mut self, i: &mut TypeParamBound) { visit_type_param_bound_mut(self, i) }

fn visit_type_paren_mut(&mut self, i: &mut TypeParen) { visit_type_paren_mut(self, i) }

fn visit_type_path_mut(&mut self, i: &mut TypePath) { visit_type_path_mut(self, i) }

fn visit_type_ptr_mut(&mut self, i: &mut TypePtr) { visit_type_ptr_mut(self, i) }

fn visit_type_reference_mut(&mut self, i: &mut TypeReference) { visit_type_reference_mut(self, i) }

fn visit_type_slice_mut(&mut self, i: &mut TypeSlice) { visit_type_slice_mut(self, i) }

fn visit_type_trait_object_mut(&mut self, i: &mut TypeTraitObject) { visit_type_trait_object_mut(self, i) }

fn visit_type_tuple_mut(&mut self, i: &mut TypeTuple) { visit_type_tuple_mut(self, i) }

fn visit_un_op_mut(&mut self, i: &mut UnOp) { visit_un_op_mut(self, i) }

fn visit_unsafety_mut(&mut self, i: &mut Unsafety) { visit_unsafety_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_use_glob_mut(&mut self, i: &mut UseGlob) { visit_use_glob_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_use_list_mut(&mut self, i: &mut UseList) { visit_use_list_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_use_path_mut(&mut self, i: &mut UsePath) { visit_use_path_mut(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_use_tree_mut(&mut self, i: &mut UseTree) { visit_use_tree_mut(self, i) }

fn visit_variant_mut(&mut self, i: &mut Variant) { visit_variant_mut(self, i) }

fn visit_variant_data_mut(&mut self, i: &mut VariantData) { visit_variant_data_mut(self, i) }

fn visit_vis_crate_mut(&mut self, i: &mut VisCrate) { visit_vis_crate_mut(self, i) }

fn visit_vis_inherited_mut(&mut self, i: &mut VisInherited) { visit_vis_inherited_mut(self, i) }

fn visit_vis_public_mut(&mut self, i: &mut VisPublic) { visit_vis_public_mut(self, i) }

fn visit_vis_restricted_mut(&mut self, i: &mut VisRestricted) { visit_vis_restricted_mut(self, i) }

fn visit_visibility_mut(&mut self, i: &mut Visibility) { visit_visibility_mut(self, i) }

fn visit_where_bound_predicate_mut(&mut self, i: &mut WhereBoundPredicate) { visit_where_bound_predicate_mut(self, i) }

fn visit_where_clause_mut(&mut self, i: &mut WhereClause) { visit_where_clause_mut(self, i) }

fn visit_where_eq_predicate_mut(&mut self, i: &mut WhereEqPredicate) { visit_where_eq_predicate_mut(self, i) }

fn visit_where_predicate_mut(&mut self, i: &mut WherePredicate) { visit_where_predicate_mut(self, i) }

fn visit_where_region_predicate_mut(&mut self, i: &mut WhereRegionPredicate) { visit_where_region_predicate_mut(self, i) }

}


pub fn visit_abi_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Abi) {
    tokens_helper(_visitor, &mut (& mut _i . extern_token).0);
    _visitor.visit_abi_kind_mut(& mut _i . kind);
}

pub fn visit_abi_kind_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut AbiKind) {
    use ::AbiKind::*;
    match *_i {
        Named(ref mut _binding_0, ) => {
            _visitor.visit_lit_mut(_binding_0);
        }
        Default => { }
    }
}

pub fn visit_angle_bracketed_generic_arguments_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut AngleBracketedGenericArguments) {
    if let Some(ref mut it) = _i . turbofish { tokens_helper(_visitor, &mut (it).0) };
    tokens_helper(_visitor, &mut (& mut _i . lt_token).0);
    for mut el in & mut _i . args { let it = el.item_mut(); _visitor.visit_generic_argument_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . gt_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_arg_captured_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ArgCaptured) {
    _visitor.visit_pat_mut(& mut _i . pat);
    tokens_helper(_visitor, &mut (& mut _i . colon_token).0);
    _visitor.visit_type_mut(& mut _i . ty);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_arg_self_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ArgSelf) {
    _visitor.visit_mutability_mut(& mut _i . mutbl);
    tokens_helper(_visitor, &mut (& mut _i . self_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_arg_self_ref_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ArgSelfRef) {
    tokens_helper(_visitor, &mut (& mut _i . and_token).0);
    tokens_helper(_visitor, &mut (& mut _i . self_token).0);
    if let Some(ref mut it) = _i . lifetime { _visitor.visit_lifetime_mut(it) };
    _visitor.visit_mutability_mut(& mut _i . mutbl);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_arm_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Arm) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    for mut el in & mut _i . pats { let it = el.item_mut(); _visitor.visit_pat_mut(it) };
    if let Some(ref mut it) = _i . if_token { tokens_helper(_visitor, &mut (it).0) };
    if let Some(ref mut it) = _i . guard { _visitor.visit_expr_mut(& mut * * it) };
    tokens_helper(_visitor, &mut (& mut _i . rocket_token).0);
    _visitor.visit_expr_mut(& mut * _i . body);
    if let Some(ref mut it) = _i . comma { tokens_helper(_visitor, &mut (it).0) };
}

pub fn visit_attr_style_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut AttrStyle) {
    use ::AttrStyle::*;
    match *_i {
        Outer => { }
        Inner(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
    }
}

pub fn visit_attribute_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Attribute) {
    _visitor.visit_attr_style_mut(& mut _i . style);
    tokens_helper(_visitor, &mut (& mut _i . pound_token).0);
    tokens_helper(_visitor, &mut (& mut _i . bracket_token).0);
    _visitor.visit_path_mut(& mut _i . path);
    // Skipped field _i . tts;
    // Skipped field _i . is_sugared_doc;
}

pub fn visit_bare_fn_arg_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut BareFnArg) {
    if let Some(ref mut it) = _i . name { 
            _visitor.visit_bare_fn_arg_name_mut(& mut ( it ) . 0);
            tokens_helper(_visitor, &mut (& mut ( it ) . 1).0);
         };
    _visitor.visit_type_mut(& mut _i . ty);
}

pub fn visit_bare_fn_arg_name_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut BareFnArgName) {
    use ::BareFnArgName::*;
    match *_i {
        Named(ref mut _binding_0, ) => {
            _visitor.visit_ident_mut(_binding_0);
        }
        Wild(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
    }
}

pub fn visit_bare_fn_type_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut BareFnType) {
    if let Some(ref mut it) = _i . lifetimes { _visitor.visit_bound_lifetimes_mut(it) };
    _visitor.visit_unsafety_mut(& mut _i . unsafety);
    if let Some(ref mut it) = _i . abi { _visitor.visit_abi_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . fn_token).0);
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
    for mut el in & mut _i . inputs { let it = el.item_mut(); _visitor.visit_bare_fn_arg_mut(it) };
    if let Some(ref mut it) = _i . variadic { tokens_helper(_visitor, &mut (it).0) };
    _visitor.visit_return_type_mut(& mut _i . output);
}

pub fn visit_bin_op_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut BinOp) {
    use ::BinOp::*;
    match *_i {
        Add(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Sub(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Mul(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Div(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Rem(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        And(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Or(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        BitXor(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        BitAnd(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        BitOr(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Shl(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Shr(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Eq(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Lt(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Le(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Ne(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Ge(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Gt(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        AddEq(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        SubEq(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        MulEq(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        DivEq(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        RemEq(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        BitXorEq(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        BitAndEq(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        BitOrEq(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        ShlEq(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        ShrEq(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_binding_mode_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut BindingMode) {
    use ::BindingMode::*;
    match *_i {
        ByRef(ref mut _binding_0, ref mut _binding_1, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
            _visitor.visit_mutability_mut(_binding_1);
        }
        ByValue(ref mut _binding_0, ) => {
            _visitor.visit_mutability_mut(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_block_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Block) {
    tokens_helper(_visitor, &mut (& mut _i . brace_token).0);
    for it in & mut _i . stmts { _visitor.visit_stmt_mut(it) };
}

pub fn visit_body_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Body) {
    use ::Body::*;
    match *_i {
        Enum(ref mut _binding_0, ) => {
            _visitor.visit_body_enum_mut(_binding_0);
        }
        Struct(ref mut _binding_0, ) => {
            _visitor.visit_body_struct_mut(_binding_0);
        }
    }
}

pub fn visit_body_enum_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut BodyEnum) {
    tokens_helper(_visitor, &mut (& mut _i . enum_token).0);
    tokens_helper(_visitor, &mut (& mut _i . brace_token).0);
    for mut el in & mut _i . variants { let it = el.item_mut(); _visitor.visit_variant_mut(it) };
}

pub fn visit_body_struct_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut BodyStruct) {
    _visitor.visit_variant_data_mut(& mut _i . data);
    tokens_helper(_visitor, &mut (& mut _i . struct_token).0);
    if let Some(ref mut it) = _i . semi_token { tokens_helper(_visitor, &mut (it).0) };
}

pub fn visit_bound_lifetimes_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut BoundLifetimes) {
    tokens_helper(_visitor, &mut (& mut _i . for_token).0);
    tokens_helper(_visitor, &mut (& mut _i . lt_token).0);
    for mut el in & mut _i . lifetimes { let it = el.item_mut(); _visitor.visit_lifetime_def_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . gt_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_capture_by_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut CaptureBy) {
    use ::CaptureBy::*;
    match *_i {
        Value(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Ref => { }
    }
}

pub fn visit_const_param_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ConstParam) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . const_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    tokens_helper(_visitor, &mut (& mut _i . colon_token).0);
    _visitor.visit_type_mut(& mut _i . ty);
    if let Some(ref mut it) = _i . eq_token { tokens_helper(_visitor, &mut (it).0) };
    if let Some(ref mut it) = _i . default { _visitor.visit_expr_mut(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_constness_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Constness) {
    use ::Constness::*;
    match *_i {
        Const(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        NotConst => { }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_defaultness_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Defaultness) {
    use ::Defaultness::*;
    match *_i {
        Default(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Final => { }
    }
}

pub fn visit_derive_input_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut DeriveInput) {
    _visitor.visit_ident_mut(& mut _i . ident);
    _visitor.visit_visibility_mut(& mut _i . vis);
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_generics_mut(& mut _i . generics);
    _visitor.visit_body_mut(& mut _i . body);
}

pub fn visit_expr_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Expr) {
    _visitor.visit_expr_kind_mut(& mut _i . node);
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_addr_of_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprAddrOf) {
    tokens_helper(_visitor, &mut (& mut _i . and_token).0);
    _visitor.visit_mutability_mut(& mut _i . mutbl);
    _visitor.visit_expr_mut(& mut * _i . expr);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_array_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprArray) {
    for mut el in & mut _i . exprs { let it = el.item_mut(); _visitor.visit_expr_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . bracket_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_assign_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprAssign) {
    _visitor.visit_expr_mut(& mut * _i . left);
    _visitor.visit_expr_mut(& mut * _i . right);
    tokens_helper(_visitor, &mut (& mut _i . eq_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_assign_op_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprAssignOp) {
    _visitor.visit_bin_op_mut(& mut _i . op);
    _visitor.visit_expr_mut(& mut * _i . left);
    _visitor.visit_expr_mut(& mut * _i . right);
}

pub fn visit_expr_binary_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprBinary) {
    _visitor.visit_bin_op_mut(& mut _i . op);
    _visitor.visit_expr_mut(& mut * _i . left);
    _visitor.visit_expr_mut(& mut * _i . right);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_block_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprBlock) {
    _visitor.visit_block_mut(& mut _i . block);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_box_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprBox) {
    _visitor.visit_expr_mut(& mut * _i . expr);
    tokens_helper(_visitor, &mut (& mut _i . box_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_break_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprBreak) {
    if let Some(ref mut it) = _i . label { _visitor.visit_lifetime_mut(it) };
    if let Some(ref mut it) = _i . expr { _visitor.visit_expr_mut(& mut * * it) };
    tokens_helper(_visitor, &mut (& mut _i . break_token).0);
}

pub fn visit_expr_call_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprCall) {
    _visitor.visit_expr_mut(& mut * _i . func);
    for mut el in & mut _i . args { let it = el.item_mut(); _visitor.visit_expr_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
}

pub fn visit_expr_cast_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprCast) {
    _visitor.visit_expr_mut(& mut * _i . expr);
    tokens_helper(_visitor, &mut (& mut _i . as_token).0);
    _visitor.visit_type_mut(& mut * _i . ty);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_catch_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprCatch) {
    tokens_helper(_visitor, &mut (& mut _i . do_token).0);
    tokens_helper(_visitor, &mut (& mut _i . catch_token).0);
    _visitor.visit_block_mut(& mut _i . block);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_closure_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprClosure) {
    _visitor.visit_capture_by_mut(& mut _i . capture);
    tokens_helper(_visitor, &mut (& mut _i . or1_token).0);
    for mut el in & mut _i . inputs { let it = el.item_mut(); _visitor.visit_fn_arg_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . or2_token).0);
    _visitor.visit_return_type_mut(& mut _i . output);
    _visitor.visit_expr_mut(& mut * _i . body);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_continue_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprContinue) {
    if let Some(ref mut it) = _i . label { _visitor.visit_lifetime_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . continue_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_field_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprField) {
    _visitor.visit_expr_mut(& mut * _i . base);
    tokens_helper(_visitor, &mut (& mut _i . dot_token).0);
    _visitor.visit_member_mut(& mut _i . member);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_for_loop_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprForLoop) {
    _visitor.visit_pat_mut(& mut * _i . pat);
    _visitor.visit_expr_mut(& mut * _i . expr);
    _visitor.visit_block_mut(& mut _i . body);
    if let Some(ref mut it) = _i . label { _visitor.visit_lifetime_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . for_token).0);
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
    tokens_helper(_visitor, &mut (& mut _i . in_token).0);
}

pub fn visit_expr_group_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprGroup) {
    _visitor.visit_expr_mut(& mut * _i . expr);
    tokens_helper(_visitor, &mut (& mut _i . group_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_if_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprIf) {
    _visitor.visit_expr_mut(& mut * _i . cond);
    _visitor.visit_block_mut(& mut _i . if_true);
    if let Some(ref mut it) = _i . if_false { _visitor.visit_expr_mut(& mut * * it) };
    tokens_helper(_visitor, &mut (& mut _i . if_token).0);
    if let Some(ref mut it) = _i . else_token { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_if_let_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprIfLet) {
    _visitor.visit_pat_mut(& mut * _i . pat);
    _visitor.visit_expr_mut(& mut * _i . expr);
    _visitor.visit_block_mut(& mut _i . if_true);
    if let Some(ref mut it) = _i . if_false { _visitor.visit_expr_mut(& mut * * it) };
    tokens_helper(_visitor, &mut (& mut _i . if_token).0);
    tokens_helper(_visitor, &mut (& mut _i . let_token).0);
    tokens_helper(_visitor, &mut (& mut _i . eq_token).0);
    if let Some(ref mut it) = _i . else_token { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_in_place_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprInPlace) {
    _visitor.visit_expr_mut(& mut * _i . place);
    _visitor.visit_in_place_kind_mut(& mut _i . kind);
    _visitor.visit_expr_mut(& mut * _i . value);
}

pub fn visit_expr_index_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprIndex) {
    _visitor.visit_expr_mut(& mut * _i . expr);
    _visitor.visit_expr_mut(& mut * _i . index);
    tokens_helper(_visitor, &mut (& mut _i . bracket_token).0);
}

pub fn visit_expr_kind_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprKind) {
    use ::ExprKind::*;
    match *_i {
        Box(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_box_mut(_binding_0));
        }
        InPlace(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_in_place_mut(_binding_0));
        }
        Array(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_array_mut(_binding_0));
        }
        Call(ref mut _binding_0, ) => {
            _visitor.visit_expr_call_mut(_binding_0);
        }
        MethodCall(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_method_call_mut(_binding_0));
        }
        Tuple(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_tuple_mut(_binding_0));
        }
        Binary(ref mut _binding_0, ) => {
            _visitor.visit_expr_binary_mut(_binding_0);
        }
        Unary(ref mut _binding_0, ) => {
            _visitor.visit_expr_unary_mut(_binding_0);
        }
        Lit(ref mut _binding_0, ) => {
            _visitor.visit_lit_mut(_binding_0);
        }
        Cast(ref mut _binding_0, ) => {
            _visitor.visit_expr_cast_mut(_binding_0);
        }
        Type(ref mut _binding_0, ) => {
            _visitor.visit_expr_type_mut(_binding_0);
        }
        If(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_if_mut(_binding_0));
        }
        IfLet(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_if_let_mut(_binding_0));
        }
        While(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_while_mut(_binding_0));
        }
        WhileLet(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_while_let_mut(_binding_0));
        }
        ForLoop(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_for_loop_mut(_binding_0));
        }
        Loop(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_loop_mut(_binding_0));
        }
        Match(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_match_mut(_binding_0));
        }
        Closure(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_closure_mut(_binding_0));
        }
        Unsafe(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_unsafe_mut(_binding_0));
        }
        Block(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_block_mut(_binding_0));
        }
        Assign(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_assign_mut(_binding_0));
        }
        AssignOp(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_assign_op_mut(_binding_0));
        }
        Field(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_field_mut(_binding_0));
        }
        Index(ref mut _binding_0, ) => {
            _visitor.visit_expr_index_mut(_binding_0);
        }
        Range(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_range_mut(_binding_0));
        }
        Path(ref mut _binding_0, ) => {
            _visitor.visit_expr_path_mut(_binding_0);
        }
        AddrOf(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_addr_of_mut(_binding_0));
        }
        Break(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_break_mut(_binding_0));
        }
        Continue(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_continue_mut(_binding_0));
        }
        Ret(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_ret_mut(_binding_0));
        }
        Macro(ref mut _binding_0, ) => {
            _visitor.visit_macro_mut(_binding_0);
        }
        Struct(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_struct_mut(_binding_0));
        }
        Repeat(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_repeat_mut(_binding_0));
        }
        Paren(ref mut _binding_0, ) => {
            _visitor.visit_expr_paren_mut(_binding_0);
        }
        Group(ref mut _binding_0, ) => {
            _visitor.visit_expr_group_mut(_binding_0);
        }
        Try(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_try_mut(_binding_0));
        }
        Catch(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_catch_mut(_binding_0));
        }
        Yield(ref mut _binding_0, ) => {
            full!(_visitor.visit_expr_yield_mut(_binding_0));
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_loop_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprLoop) {
    _visitor.visit_block_mut(& mut _i . body);
    if let Some(ref mut it) = _i . label { _visitor.visit_lifetime_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . loop_token).0);
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_match_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprMatch) {
    tokens_helper(_visitor, &mut (& mut _i . match_token).0);
    tokens_helper(_visitor, &mut (& mut _i . brace_token).0);
    _visitor.visit_expr_mut(& mut * _i . expr);
    for it in & mut _i . arms { _visitor.visit_arm_mut(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_method_call_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprMethodCall) {
    _visitor.visit_expr_mut(& mut * _i . expr);
    _visitor.visit_ident_mut(& mut _i . method);
    for mut el in & mut _i . typarams { let it = el.item_mut(); _visitor.visit_type_mut(it) };
    for mut el in & mut _i . args { let it = el.item_mut(); _visitor.visit_expr_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
    tokens_helper(_visitor, &mut (& mut _i . dot_token).0);
    if let Some(ref mut it) = _i . lt_token { tokens_helper(_visitor, &mut (it).0) };
    if let Some(ref mut it) = _i . colon2_token { tokens_helper(_visitor, &mut (it).0) };
    if let Some(ref mut it) = _i . gt_token { tokens_helper(_visitor, &mut (it).0) };
}

pub fn visit_expr_paren_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprParen) {
    _visitor.visit_expr_mut(& mut * _i . expr);
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
}

pub fn visit_expr_path_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprPath) {
    if let Some(ref mut it) = _i . qself { _visitor.visit_qself_mut(it) };
    _visitor.visit_path_mut(& mut _i . path);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_range_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprRange) {
    if let Some(ref mut it) = _i . from { _visitor.visit_expr_mut(& mut * * it) };
    if let Some(ref mut it) = _i . to { _visitor.visit_expr_mut(& mut * * it) };
    _visitor.visit_range_limits_mut(& mut _i . limits);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_repeat_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprRepeat) {
    tokens_helper(_visitor, &mut (& mut _i . bracket_token).0);
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
    _visitor.visit_expr_mut(& mut * _i . expr);
    _visitor.visit_expr_mut(& mut * _i . amt);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_ret_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprRet) {
    if let Some(ref mut it) = _i . expr { _visitor.visit_expr_mut(& mut * * it) };
    tokens_helper(_visitor, &mut (& mut _i . return_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_struct_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprStruct) {
    _visitor.visit_path_mut(& mut _i . path);
    for mut el in & mut _i . fields { let it = el.item_mut(); _visitor.visit_field_value_mut(it) };
    if let Some(ref mut it) = _i . rest { _visitor.visit_expr_mut(& mut * * it) };
    if let Some(ref mut it) = _i . dot2_token { tokens_helper(_visitor, &mut (it).0) };
    tokens_helper(_visitor, &mut (& mut _i . brace_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_try_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprTry) {
    _visitor.visit_expr_mut(& mut * _i . expr);
    tokens_helper(_visitor, &mut (& mut _i . question_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_tuple_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprTuple) {
    for mut el in & mut _i . args { let it = el.item_mut(); _visitor.visit_expr_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
}

pub fn visit_expr_type_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprType) {
    _visitor.visit_expr_mut(& mut * _i . expr);
    tokens_helper(_visitor, &mut (& mut _i . colon_token).0);
    _visitor.visit_type_mut(& mut * _i . ty);
}

pub fn visit_expr_unary_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprUnary) {
    _visitor.visit_un_op_mut(& mut _i . op);
    _visitor.visit_expr_mut(& mut * _i . expr);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_unsafe_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprUnsafe) {
    tokens_helper(_visitor, &mut (& mut _i . unsafe_token).0);
    _visitor.visit_block_mut(& mut _i . block);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_while_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprWhile) {
    _visitor.visit_expr_mut(& mut * _i . cond);
    _visitor.visit_block_mut(& mut _i . body);
    if let Some(ref mut it) = _i . label { _visitor.visit_lifetime_mut(it) };
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
    tokens_helper(_visitor, &mut (& mut _i . while_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_while_let_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprWhileLet) {
    _visitor.visit_pat_mut(& mut * _i . pat);
    _visitor.visit_expr_mut(& mut * _i . expr);
    _visitor.visit_block_mut(& mut _i . body);
    if let Some(ref mut it) = _i . label { _visitor.visit_lifetime_mut(it) };
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
    tokens_helper(_visitor, &mut (& mut _i . while_token).0);
    tokens_helper(_visitor, &mut (& mut _i . let_token).0);
    tokens_helper(_visitor, &mut (& mut _i . eq_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_yield_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ExprYield) {
    tokens_helper(_visitor, &mut (& mut _i . yield_token).0);
    if let Some(ref mut it) = _i . expr { _visitor.visit_expr_mut(& mut * * it) };
}

pub fn visit_field_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Field) {
    if let Some(ref mut it) = _i . ident { _visitor.visit_ident_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_type_mut(& mut _i . ty);
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_field_pat_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut FieldPat) {
    _visitor.visit_member_mut(& mut _i . member);
    _visitor.visit_pat_mut(& mut * _i . pat);
    // Skipped field _i . is_shorthand;
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_field_value_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut FieldValue) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_member_mut(& mut _i . member);
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
    _visitor.visit_expr_mut(& mut _i . expr);
    // Skipped field _i . is_shorthand;
}
# [ cfg ( feature = "full" ) ]
pub fn visit_file_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut File) {
    // Skipped field _i . shebang;
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    for it in & mut _i . items { _visitor.visit_item_mut(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_fn_arg_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut FnArg) {
    use ::FnArg::*;
    match *_i {
        SelfRef(ref mut _binding_0, ) => {
            _visitor.visit_arg_self_ref_mut(_binding_0);
        }
        SelfValue(ref mut _binding_0, ) => {
            _visitor.visit_arg_self_mut(_binding_0);
        }
        Captured(ref mut _binding_0, ) => {
            _visitor.visit_arg_captured_mut(_binding_0);
        }
        Inferred(ref mut _binding_0, ) => {
            _visitor.visit_pat_mut(_binding_0);
        }
        Ignored(ref mut _binding_0, ) => {
            _visitor.visit_type_mut(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_fn_decl_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut FnDecl) {
    tokens_helper(_visitor, &mut (& mut _i . fn_token).0);
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
    for mut el in & mut _i . inputs { let it = el.item_mut(); _visitor.visit_fn_arg_mut(it) };
    _visitor.visit_return_type_mut(& mut _i . output);
    _visitor.visit_generics_mut(& mut _i . generics);
    if let Some(ref mut it) = _i . variadic { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_foreign_item_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ForeignItem) {
    use ::ForeignItem::*;
    match *_i {
        Fn(ref mut _binding_0, ) => {
            _visitor.visit_foreign_item_fn_mut(_binding_0);
        }
        Static(ref mut _binding_0, ) => {
            _visitor.visit_foreign_item_static_mut(_binding_0);
        }
        Type(ref mut _binding_0, ) => {
            _visitor.visit_foreign_item_type_mut(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_foreign_item_fn_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ForeignItemFn) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    _visitor.visit_ident_mut(& mut _i . ident);
    _visitor.visit_fn_decl_mut(& mut * _i . decl);
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_foreign_item_static_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ForeignItemStatic) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    tokens_helper(_visitor, &mut (& mut _i . static_token).0);
    _visitor.visit_mutability_mut(& mut _i . mutbl);
    _visitor.visit_ident_mut(& mut _i . ident);
    tokens_helper(_visitor, &mut (& mut _i . colon_token).0);
    _visitor.visit_type_mut(& mut * _i . ty);
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_foreign_item_type_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ForeignItemType) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    tokens_helper(_visitor, &mut (& mut _i . type_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
}

pub fn visit_generic_argument_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut GenericArgument) {
    use ::GenericArgument::*;
    match *_i {
        Lifetime(ref mut _binding_0, ) => {
            _visitor.visit_lifetime_mut(_binding_0);
        }
        Type(ref mut _binding_0, ) => {
            _visitor.visit_type_mut(_binding_0);
        }
        TypeBinding(ref mut _binding_0, ) => {
            _visitor.visit_type_binding_mut(_binding_0);
        }
        Const(ref mut _binding_0, ) => {
            _visitor.visit_expr_mut(_binding_0);
        }
    }
}

pub fn visit_generic_param_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut GenericParam) {
    use ::GenericParam::*;
    match *_i {
        Lifetime(ref mut _binding_0, ) => {
            _visitor.visit_lifetime_def_mut(_binding_0);
        }
        Type(ref mut _binding_0, ) => {
            _visitor.visit_type_param_mut(_binding_0);
        }
        Const(ref mut _binding_0, ) => {
            _visitor.visit_const_param_mut(_binding_0);
        }
    }
}

pub fn visit_generics_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Generics) {
    if let Some(ref mut it) = _i . lt_token { tokens_helper(_visitor, &mut (it).0) };
    for mut el in & mut _i . params { let it = el.item_mut(); _visitor.visit_generic_param_mut(it) };
    if let Some(ref mut it) = _i . gt_token { tokens_helper(_visitor, &mut (it).0) };
    if let Some(ref mut it) = _i . where_clause { _visitor.visit_where_clause_mut(it) };
}

pub fn visit_ident_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Ident) {
    // Skipped field _i . sym;
    _visitor.visit_span_mut(& mut _i . span);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_impl_item_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ImplItem) {
    use ::ImplItem::*;
    match *_i {
        Const(ref mut _binding_0, ) => {
            _visitor.visit_impl_item_const_mut(_binding_0);
        }
        Method(ref mut _binding_0, ) => {
            _visitor.visit_impl_item_method_mut(_binding_0);
        }
        Type(ref mut _binding_0, ) => {
            _visitor.visit_impl_item_type_mut(_binding_0);
        }
        Macro(ref mut _binding_0, ) => {
            _visitor.visit_impl_item_macro_mut(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_impl_item_const_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ImplItemConst) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    _visitor.visit_defaultness_mut(& mut _i . defaultness);
    tokens_helper(_visitor, &mut (& mut _i . const_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    tokens_helper(_visitor, &mut (& mut _i . colon_token).0);
    _visitor.visit_type_mut(& mut _i . ty);
    tokens_helper(_visitor, &mut (& mut _i . eq_token).0);
    _visitor.visit_expr_mut(& mut _i . expr);
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_impl_item_macro_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ImplItemMacro) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_macro_mut(& mut _i . mac);
    if let Some(ref mut it) = _i . semi_token { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_impl_item_method_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ImplItemMethod) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    _visitor.visit_defaultness_mut(& mut _i . defaultness);
    _visitor.visit_method_sig_mut(& mut _i . sig);
    _visitor.visit_block_mut(& mut _i . block);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_impl_item_type_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ImplItemType) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    _visitor.visit_defaultness_mut(& mut _i . defaultness);
    tokens_helper(_visitor, &mut (& mut _i . type_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    _visitor.visit_generics_mut(& mut _i . generics);
    tokens_helper(_visitor, &mut (& mut _i . eq_token).0);
    _visitor.visit_type_mut(& mut _i . ty);
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_impl_polarity_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ImplPolarity) {
    use ::ImplPolarity::*;
    match *_i {
        Positive => { }
        Negative(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_in_place_kind_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut InPlaceKind) {
    use ::InPlaceKind::*;
    match *_i {
        Arrow(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        In(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_index_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Index) {
    // Skipped field _i . index;
    _visitor.visit_span_mut(& mut _i . span);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Item) {
    use ::Item::*;
    match *_i {
        ExternCrate(ref mut _binding_0, ) => {
            _visitor.visit_item_extern_crate_mut(_binding_0);
        }
        Use(ref mut _binding_0, ) => {
            _visitor.visit_item_use_mut(_binding_0);
        }
        Static(ref mut _binding_0, ) => {
            _visitor.visit_item_static_mut(_binding_0);
        }
        Const(ref mut _binding_0, ) => {
            _visitor.visit_item_const_mut(_binding_0);
        }
        Fn(ref mut _binding_0, ) => {
            _visitor.visit_item_fn_mut(_binding_0);
        }
        Mod(ref mut _binding_0, ) => {
            _visitor.visit_item_mod_mut(_binding_0);
        }
        ForeignMod(ref mut _binding_0, ) => {
            _visitor.visit_item_foreign_mod_mut(_binding_0);
        }
        Type(ref mut _binding_0, ) => {
            _visitor.visit_item_type_mut(_binding_0);
        }
        Enum(ref mut _binding_0, ) => {
            _visitor.visit_item_enum_mut(_binding_0);
        }
        Struct(ref mut _binding_0, ) => {
            _visitor.visit_item_struct_mut(_binding_0);
        }
        Union(ref mut _binding_0, ) => {
            _visitor.visit_item_union_mut(_binding_0);
        }
        Trait(ref mut _binding_0, ) => {
            _visitor.visit_item_trait_mut(_binding_0);
        }
        DefaultImpl(ref mut _binding_0, ) => {
            _visitor.visit_item_default_impl_mut(_binding_0);
        }
        Impl(ref mut _binding_0, ) => {
            _visitor.visit_item_impl_mut(_binding_0);
        }
        Macro(ref mut _binding_0, ) => {
            _visitor.visit_item_macro_mut(_binding_0);
        }
        Macro2(ref mut _binding_0, ) => {
            _visitor.visit_item_macro2_mut(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_const_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemConst) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    tokens_helper(_visitor, &mut (& mut _i . const_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    tokens_helper(_visitor, &mut (& mut _i . colon_token).0);
    _visitor.visit_type_mut(& mut * _i . ty);
    tokens_helper(_visitor, &mut (& mut _i . eq_token).0);
    _visitor.visit_expr_mut(& mut * _i . expr);
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_default_impl_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemDefaultImpl) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_unsafety_mut(& mut _i . unsafety);
    tokens_helper(_visitor, &mut (& mut _i . impl_token).0);
    _visitor.visit_path_mut(& mut _i . path);
    tokens_helper(_visitor, &mut (& mut _i . for_token).0);
    tokens_helper(_visitor, &mut (& mut _i . dot2_token).0);
    tokens_helper(_visitor, &mut (& mut _i . brace_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_enum_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemEnum) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    tokens_helper(_visitor, &mut (& mut _i . enum_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    _visitor.visit_generics_mut(& mut _i . generics);
    tokens_helper(_visitor, &mut (& mut _i . brace_token).0);
    for mut el in & mut _i . variants { let it = el.item_mut(); _visitor.visit_variant_mut(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_extern_crate_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemExternCrate) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    tokens_helper(_visitor, &mut (& mut _i . extern_token).0);
    tokens_helper(_visitor, &mut (& mut _i . crate_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    if let Some(ref mut it) = _i . rename { 
            tokens_helper(_visitor, &mut (& mut ( it ) . 0).0);
            _visitor.visit_ident_mut(& mut ( it ) . 1);
         };
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_fn_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemFn) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    _visitor.visit_constness_mut(& mut _i . constness);
    _visitor.visit_unsafety_mut(& mut _i . unsafety);
    if let Some(ref mut it) = _i . abi { _visitor.visit_abi_mut(it) };
    _visitor.visit_fn_decl_mut(& mut * _i . decl);
    _visitor.visit_ident_mut(& mut _i . ident);
    _visitor.visit_block_mut(& mut * _i . block);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_foreign_mod_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemForeignMod) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_abi_mut(& mut _i . abi);
    tokens_helper(_visitor, &mut (& mut _i . brace_token).0);
    for it in & mut _i . items { _visitor.visit_foreign_item_mut(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_impl_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemImpl) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_defaultness_mut(& mut _i . defaultness);
    _visitor.visit_unsafety_mut(& mut _i . unsafety);
    tokens_helper(_visitor, &mut (& mut _i . impl_token).0);
    _visitor.visit_generics_mut(& mut _i . generics);
    if let Some(ref mut it) = _i . trait_ { 
            _visitor.visit_impl_polarity_mut(& mut ( it ) . 0);
            _visitor.visit_path_mut(& mut ( it ) . 1);
            tokens_helper(_visitor, &mut (& mut ( it ) . 2).0);
         };
    _visitor.visit_type_mut(& mut * _i . self_ty);
    tokens_helper(_visitor, &mut (& mut _i . brace_token).0);
    for it in & mut _i . items { _visitor.visit_impl_item_mut(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_macro_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemMacro) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    if let Some(ref mut it) = _i . ident { _visitor.visit_ident_mut(it) };
    _visitor.visit_macro_mut(& mut _i . mac);
    if let Some(ref mut it) = _i . semi_token { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_macro2_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemMacro2) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    tokens_helper(_visitor, &mut (& mut _i . macro_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    // Skipped field _i . args;
    // Skipped field _i . body;
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_mod_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemMod) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    tokens_helper(_visitor, &mut (& mut _i . mod_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    if let Some(ref mut it) = _i . content { 
            tokens_helper(_visitor, &mut (& mut ( it ) . 0).0);
            for it in & mut ( it ) . 1 { _visitor.visit_item_mut(it) };
         };
    if let Some(ref mut it) = _i . semi { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_static_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemStatic) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    tokens_helper(_visitor, &mut (& mut _i . static_token).0);
    _visitor.visit_mutability_mut(& mut _i . mutbl);
    _visitor.visit_ident_mut(& mut _i . ident);
    tokens_helper(_visitor, &mut (& mut _i . colon_token).0);
    _visitor.visit_type_mut(& mut * _i . ty);
    tokens_helper(_visitor, &mut (& mut _i . eq_token).0);
    _visitor.visit_expr_mut(& mut * _i . expr);
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_struct_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemStruct) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    tokens_helper(_visitor, &mut (& mut _i . struct_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    _visitor.visit_generics_mut(& mut _i . generics);
    _visitor.visit_variant_data_mut(& mut _i . data);
    if let Some(ref mut it) = _i . semi_token { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_trait_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemTrait) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    _visitor.visit_unsafety_mut(& mut _i . unsafety);
    if let Some(ref mut it) = _i . auto_token { tokens_helper(_visitor, &mut (it).0) };
    tokens_helper(_visitor, &mut (& mut _i . trait_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    _visitor.visit_generics_mut(& mut _i . generics);
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
    for mut el in & mut _i . supertraits { let it = el.item_mut(); _visitor.visit_type_param_bound_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . brace_token).0);
    for it in & mut _i . items { _visitor.visit_trait_item_mut(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_type_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemType) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    tokens_helper(_visitor, &mut (& mut _i . type_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    _visitor.visit_generics_mut(& mut _i . generics);
    tokens_helper(_visitor, &mut (& mut _i . eq_token).0);
    _visitor.visit_type_mut(& mut * _i . ty);
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_union_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemUnion) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    tokens_helper(_visitor, &mut (& mut _i . union_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    _visitor.visit_generics_mut(& mut _i . generics);
    _visitor.visit_variant_data_mut(& mut _i . data);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_use_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ItemUse) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_visibility_mut(& mut _i . vis);
    tokens_helper(_visitor, &mut (& mut _i . use_token).0);
    if let Some(ref mut it) = _i . leading_colon { tokens_helper(_visitor, &mut (it).0) };
    for mut el in & mut _i . prefix { let it = el.item_mut(); _visitor.visit_ident_mut(it) };
    _visitor.visit_use_tree_mut(& mut _i . tree);
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
}

pub fn visit_lifetime_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Lifetime) {
    // Skipped field _i . sym;
    _visitor.visit_span_mut(& mut _i . span);
}

pub fn visit_lifetime_def_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut LifetimeDef) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_lifetime_mut(& mut _i . lifetime);
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
    for mut el in & mut _i . bounds { let it = el.item_mut(); _visitor.visit_lifetime_mut(it) };
}

pub fn visit_lit_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Lit) {
    // Skipped field _i . value;
    _visitor.visit_span_mut(& mut _i . span);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_local_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Local) {
    tokens_helper(_visitor, &mut (& mut _i . let_token).0);
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
    if let Some(ref mut it) = _i . eq_token { tokens_helper(_visitor, &mut (it).0) };
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
    _visitor.visit_pat_mut(& mut * _i . pat);
    if let Some(ref mut it) = _i . ty { _visitor.visit_type_mut(& mut * * it) };
    if let Some(ref mut it) = _i . init { _visitor.visit_expr_mut(& mut * * it) };
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
}

pub fn visit_macro_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Macro) {
    _visitor.visit_path_mut(& mut _i . path);
    tokens_helper(_visitor, &mut (& mut _i . bang_token).0);
    // Skipped field _i . tokens;
}
# [ cfg ( feature = "full" ) ]
pub fn visit_member_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Member) {
    use ::Member::*;
    match *_i {
        Named(ref mut _binding_0, ) => {
            _visitor.visit_ident_mut(_binding_0);
        }
        Unnamed(ref mut _binding_0, ) => {
            _visitor.visit_index_mut(_binding_0);
        }
    }
}

pub fn visit_meta_item_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut MetaItem) {
    use ::MetaItem::*;
    match *_i {
        Term(ref mut _binding_0, ) => {
            _visitor.visit_ident_mut(_binding_0);
        }
        List(ref mut _binding_0, ) => {
            _visitor.visit_meta_item_list_mut(_binding_0);
        }
        NameValue(ref mut _binding_0, ) => {
            _visitor.visit_meta_name_value_mut(_binding_0);
        }
    }
}

pub fn visit_meta_item_list_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut MetaItemList) {
    _visitor.visit_ident_mut(& mut _i . ident);
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
    for mut el in & mut _i . nested { let it = el.item_mut(); _visitor.visit_nested_meta_item_mut(it) };
}

pub fn visit_meta_name_value_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut MetaNameValue) {
    _visitor.visit_ident_mut(& mut _i . ident);
    tokens_helper(_visitor, &mut (& mut _i . eq_token).0);
    _visitor.visit_lit_mut(& mut _i . lit);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_method_sig_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut MethodSig) {
    _visitor.visit_constness_mut(& mut _i . constness);
    _visitor.visit_unsafety_mut(& mut _i . unsafety);
    if let Some(ref mut it) = _i . abi { _visitor.visit_abi_mut(it) };
    _visitor.visit_ident_mut(& mut _i . ident);
    _visitor.visit_fn_decl_mut(& mut _i . decl);
}

pub fn visit_mut_type_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut MutType) {
    _visitor.visit_type_mut(& mut _i . ty);
    _visitor.visit_mutability_mut(& mut _i . mutability);
}

pub fn visit_mutability_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Mutability) {
    use ::Mutability::*;
    match *_i {
        Mutable(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Immutable => { }
    }
}

pub fn visit_nested_meta_item_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut NestedMetaItem) {
    use ::NestedMetaItem::*;
    match *_i {
        MetaItem(ref mut _binding_0, ) => {
            _visitor.visit_meta_item_mut(_binding_0);
        }
        Literal(ref mut _binding_0, ) => {
            _visitor.visit_lit_mut(_binding_0);
        }
    }
}

pub fn visit_parenthesized_generic_arguments_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ParenthesizedGenericArguments) {
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
    for mut el in & mut _i . inputs { let it = el.item_mut(); _visitor.visit_type_mut(it) };
    _visitor.visit_return_type_mut(& mut _i . output);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Pat) {
    use ::Pat::*;
    match *_i {
        Wild(ref mut _binding_0, ) => {
            _visitor.visit_pat_wild_mut(_binding_0);
        }
        Ident(ref mut _binding_0, ) => {
            _visitor.visit_pat_ident_mut(_binding_0);
        }
        Struct(ref mut _binding_0, ) => {
            _visitor.visit_pat_struct_mut(_binding_0);
        }
        TupleStruct(ref mut _binding_0, ) => {
            _visitor.visit_pat_tuple_struct_mut(_binding_0);
        }
        Path(ref mut _binding_0, ) => {
            _visitor.visit_pat_path_mut(_binding_0);
        }
        Tuple(ref mut _binding_0, ) => {
            _visitor.visit_pat_tuple_mut(_binding_0);
        }
        Box(ref mut _binding_0, ) => {
            _visitor.visit_pat_box_mut(_binding_0);
        }
        Ref(ref mut _binding_0, ) => {
            _visitor.visit_pat_ref_mut(_binding_0);
        }
        Lit(ref mut _binding_0, ) => {
            _visitor.visit_pat_lit_mut(_binding_0);
        }
        Range(ref mut _binding_0, ) => {
            _visitor.visit_pat_range_mut(_binding_0);
        }
        Slice(ref mut _binding_0, ) => {
            _visitor.visit_pat_slice_mut(_binding_0);
        }
        Macro(ref mut _binding_0, ) => {
            _visitor.visit_macro_mut(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_box_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PatBox) {
    _visitor.visit_pat_mut(& mut * _i . pat);
    tokens_helper(_visitor, &mut (& mut _i . box_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_ident_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PatIdent) {
    _visitor.visit_binding_mode_mut(& mut _i . mode);
    _visitor.visit_ident_mut(& mut _i . ident);
    if let Some(ref mut it) = _i . subpat { _visitor.visit_pat_mut(& mut * * it) };
    if let Some(ref mut it) = _i . at_token { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_lit_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PatLit) {
    _visitor.visit_expr_mut(& mut * _i . expr);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_path_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PatPath) {
    if let Some(ref mut it) = _i . qself { _visitor.visit_qself_mut(it) };
    _visitor.visit_path_mut(& mut _i . path);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_range_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PatRange) {
    _visitor.visit_expr_mut(& mut * _i . lo);
    _visitor.visit_expr_mut(& mut * _i . hi);
    _visitor.visit_range_limits_mut(& mut _i . limits);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_ref_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PatRef) {
    _visitor.visit_pat_mut(& mut * _i . pat);
    _visitor.visit_mutability_mut(& mut _i . mutbl);
    tokens_helper(_visitor, &mut (& mut _i . and_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_slice_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PatSlice) {
    for mut el in & mut _i . front { let it = el.item_mut(); _visitor.visit_pat_mut(it) };
    if let Some(ref mut it) = _i . middle { _visitor.visit_pat_mut(& mut * * it) };
    for mut el in & mut _i . back { let it = el.item_mut(); _visitor.visit_pat_mut(it) };
    if let Some(ref mut it) = _i . dot2_token { tokens_helper(_visitor, &mut (it).0) };
    if let Some(ref mut it) = _i . comma_token { tokens_helper(_visitor, &mut (it).0) };
    tokens_helper(_visitor, &mut (& mut _i . bracket_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_struct_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PatStruct) {
    _visitor.visit_path_mut(& mut _i . path);
    for mut el in & mut _i . fields { let it = el.item_mut(); _visitor.visit_field_pat_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . brace_token).0);
    if let Some(ref mut it) = _i . dot2_token { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_tuple_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PatTuple) {
    for mut el in & mut _i . pats { let it = el.item_mut(); _visitor.visit_pat_mut(it) };
    // Skipped field _i . dots_pos;
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
    if let Some(ref mut it) = _i . dot2_token { tokens_helper(_visitor, &mut (it).0) };
    if let Some(ref mut it) = _i . comma_token { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_tuple_struct_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PatTupleStruct) {
    _visitor.visit_path_mut(& mut _i . path);
    _visitor.visit_pat_tuple_mut(& mut _i . pat);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_wild_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PatWild) {
    tokens_helper(_visitor, &mut (& mut _i . underscore_token).0);
}

pub fn visit_path_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Path) {
    if let Some(ref mut it) = _i . leading_colon { tokens_helper(_visitor, &mut (it).0) };
    for mut el in & mut _i . segments { let it = el.item_mut(); _visitor.visit_path_segment_mut(it) };
}

pub fn visit_path_arguments_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PathArguments) {
    use ::PathArguments::*;
    match *_i {
        None => { }
        AngleBracketed(ref mut _binding_0, ) => {
            _visitor.visit_angle_bracketed_generic_arguments_mut(_binding_0);
        }
        Parenthesized(ref mut _binding_0, ) => {
            _visitor.visit_parenthesized_generic_arguments_mut(_binding_0);
        }
    }
}

pub fn visit_path_segment_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PathSegment) {
    _visitor.visit_ident_mut(& mut _i . ident);
    _visitor.visit_path_arguments_mut(& mut _i . arguments);
}

pub fn visit_poly_trait_ref_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut PolyTraitRef) {
    if let Some(ref mut it) = _i . bound_lifetimes { _visitor.visit_bound_lifetimes_mut(it) };
    _visitor.visit_path_mut(& mut _i . trait_ref);
}

pub fn visit_qself_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut QSelf) {
    tokens_helper(_visitor, &mut (& mut _i . lt_token).0);
    _visitor.visit_type_mut(& mut * _i . ty);
    // Skipped field _i . position;
    if let Some(ref mut it) = _i . as_token { tokens_helper(_visitor, &mut (it).0) };
    tokens_helper(_visitor, &mut (& mut _i . gt_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_range_limits_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut RangeLimits) {
    use ::RangeLimits::*;
    match *_i {
        HalfOpen(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Closed(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
    }
}

pub fn visit_return_type_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut ReturnType) {
    use ::ReturnType::*;
    match *_i {
        Default => { }
        Type(ref mut _binding_0, ref mut _binding_1, ) => {
            _visitor.visit_type_mut(& mut * * _binding_0);
            tokens_helper(_visitor, &mut (_binding_1).0);
        }
    }
}

pub fn visit_span_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Span) {
}
# [ cfg ( feature = "full" ) ]
pub fn visit_stmt_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Stmt) {
    use ::Stmt::*;
    match *_i {
        Local(ref mut _binding_0, ) => {
            _visitor.visit_local_mut(& mut * * _binding_0);
        }
        Item(ref mut _binding_0, ) => {
            _visitor.visit_item_mut(& mut * * _binding_0);
        }
        Expr(ref mut _binding_0, ) => {
            _visitor.visit_expr_mut(& mut * * _binding_0);
        }
        Semi(ref mut _binding_0, ref mut _binding_1, ) => {
            _visitor.visit_expr_mut(& mut * * _binding_0);
            tokens_helper(_visitor, &mut (_binding_1).0);
        }
    }
}

pub fn visit_trait_bound_modifier_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TraitBoundModifier) {
    use ::TraitBoundModifier::*;
    match *_i {
        None => { }
        Maybe(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_trait_item_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TraitItem) {
    use ::TraitItem::*;
    match *_i {
        Const(ref mut _binding_0, ) => {
            _visitor.visit_trait_item_const_mut(_binding_0);
        }
        Method(ref mut _binding_0, ) => {
            _visitor.visit_trait_item_method_mut(_binding_0);
        }
        Type(ref mut _binding_0, ) => {
            _visitor.visit_trait_item_type_mut(_binding_0);
        }
        Macro(ref mut _binding_0, ) => {
            _visitor.visit_trait_item_macro_mut(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_trait_item_const_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TraitItemConst) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . const_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    tokens_helper(_visitor, &mut (& mut _i . colon_token).0);
    _visitor.visit_type_mut(& mut _i . ty);
    if let Some(ref mut it) = _i . default { 
            tokens_helper(_visitor, &mut (& mut ( it ) . 0).0);
            _visitor.visit_expr_mut(& mut ( it ) . 1);
         };
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_trait_item_macro_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TraitItemMacro) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_macro_mut(& mut _i . mac);
    if let Some(ref mut it) = _i . semi_token { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_trait_item_method_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TraitItemMethod) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_method_sig_mut(& mut _i . sig);
    if let Some(ref mut it) = _i . default { _visitor.visit_block_mut(it) };
    if let Some(ref mut it) = _i . semi_token { tokens_helper(_visitor, &mut (it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_trait_item_type_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TraitItemType) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    tokens_helper(_visitor, &mut (& mut _i . type_token).0);
    _visitor.visit_ident_mut(& mut _i . ident);
    _visitor.visit_generics_mut(& mut _i . generics);
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
    for mut el in & mut _i . bounds { let it = el.item_mut(); _visitor.visit_type_param_bound_mut(it) };
    if let Some(ref mut it) = _i . default { 
            tokens_helper(_visitor, &mut (& mut ( it ) . 0).0);
            _visitor.visit_type_mut(& mut ( it ) . 1);
         };
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
}

pub fn visit_type_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Type) {
    use ::Type::*;
    match *_i {
        Slice(ref mut _binding_0, ) => {
            _visitor.visit_type_slice_mut(_binding_0);
        }
        Array(ref mut _binding_0, ) => {
            _visitor.visit_type_array_mut(_binding_0);
        }
        Ptr(ref mut _binding_0, ) => {
            _visitor.visit_type_ptr_mut(_binding_0);
        }
        Reference(ref mut _binding_0, ) => {
            _visitor.visit_type_reference_mut(_binding_0);
        }
        BareFn(ref mut _binding_0, ) => {
            _visitor.visit_type_bare_fn_mut(_binding_0);
        }
        Never(ref mut _binding_0, ) => {
            _visitor.visit_type_never_mut(_binding_0);
        }
        Tuple(ref mut _binding_0, ) => {
            _visitor.visit_type_tuple_mut(_binding_0);
        }
        Path(ref mut _binding_0, ) => {
            _visitor.visit_type_path_mut(_binding_0);
        }
        TraitObject(ref mut _binding_0, ) => {
            _visitor.visit_type_trait_object_mut(_binding_0);
        }
        ImplTrait(ref mut _binding_0, ) => {
            _visitor.visit_type_impl_trait_mut(_binding_0);
        }
        Paren(ref mut _binding_0, ) => {
            _visitor.visit_type_paren_mut(_binding_0);
        }
        Group(ref mut _binding_0, ) => {
            _visitor.visit_type_group_mut(_binding_0);
        }
        Infer(ref mut _binding_0, ) => {
            _visitor.visit_type_infer_mut(_binding_0);
        }
        Macro(ref mut _binding_0, ) => {
            _visitor.visit_macro_mut(_binding_0);
        }
    }
}

pub fn visit_type_array_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeArray) {
    tokens_helper(_visitor, &mut (& mut _i . bracket_token).0);
    _visitor.visit_type_mut(& mut * _i . ty);
    tokens_helper(_visitor, &mut (& mut _i . semi_token).0);
    _visitor.visit_expr_mut(& mut _i . amt);
}

pub fn visit_type_bare_fn_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeBareFn) {
    _visitor.visit_bare_fn_type_mut(& mut * _i . ty);
}

pub fn visit_type_binding_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeBinding) {
    _visitor.visit_ident_mut(& mut _i . ident);
    tokens_helper(_visitor, &mut (& mut _i . eq_token).0);
    _visitor.visit_type_mut(& mut _i . ty);
}

pub fn visit_type_group_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeGroup) {
    tokens_helper(_visitor, &mut (& mut _i . group_token).0);
    _visitor.visit_type_mut(& mut * _i . ty);
}

pub fn visit_type_impl_trait_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeImplTrait) {
    tokens_helper(_visitor, &mut (& mut _i . impl_token).0);
    for mut el in & mut _i . bounds { let it = el.item_mut(); _visitor.visit_type_param_bound_mut(it) };
}

pub fn visit_type_infer_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeInfer) {
    tokens_helper(_visitor, &mut (& mut _i . underscore_token).0);
}

pub fn visit_type_never_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeNever) {
    tokens_helper(_visitor, &mut (& mut _i . bang_token).0);
}

pub fn visit_type_param_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeParam) {
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_ident_mut(& mut _i . ident);
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
    for mut el in & mut _i . bounds { let it = el.item_mut(); _visitor.visit_type_param_bound_mut(it) };
    if let Some(ref mut it) = _i . eq_token { tokens_helper(_visitor, &mut (it).0) };
    if let Some(ref mut it) = _i . default { _visitor.visit_type_mut(it) };
}

pub fn visit_type_param_bound_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeParamBound) {
    use ::TypeParamBound::*;
    match *_i {
        Trait(ref mut _binding_0, ref mut _binding_1, ) => {
            _visitor.visit_poly_trait_ref_mut(_binding_0);
            _visitor.visit_trait_bound_modifier_mut(_binding_1);
        }
        Region(ref mut _binding_0, ) => {
            _visitor.visit_lifetime_mut(_binding_0);
        }
    }
}

pub fn visit_type_paren_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeParen) {
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
    _visitor.visit_type_mut(& mut * _i . ty);
}

pub fn visit_type_path_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypePath) {
    if let Some(ref mut it) = _i . qself { _visitor.visit_qself_mut(it) };
    _visitor.visit_path_mut(& mut _i . path);
}

pub fn visit_type_ptr_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypePtr) {
    tokens_helper(_visitor, &mut (& mut _i . star_token).0);
    if let Some(ref mut it) = _i . const_token { tokens_helper(_visitor, &mut (it).0) };
    _visitor.visit_mut_type_mut(& mut * _i . ty);
}

pub fn visit_type_reference_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeReference) {
    tokens_helper(_visitor, &mut (& mut _i . and_token).0);
    if let Some(ref mut it) = _i . lifetime { _visitor.visit_lifetime_mut(it) };
    _visitor.visit_mut_type_mut(& mut * _i . ty);
}

pub fn visit_type_slice_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeSlice) {
    _visitor.visit_type_mut(& mut * _i . ty);
    tokens_helper(_visitor, &mut (& mut _i . bracket_token).0);
}

pub fn visit_type_trait_object_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeTraitObject) {
    if let Some(ref mut it) = _i . dyn_token { tokens_helper(_visitor, &mut (it).0) };
    for mut el in & mut _i . bounds { let it = el.item_mut(); _visitor.visit_type_param_bound_mut(it) };
}

pub fn visit_type_tuple_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut TypeTuple) {
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
    for mut el in & mut _i . tys { let it = el.item_mut(); _visitor.visit_type_mut(it) };
}

pub fn visit_un_op_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut UnOp) {
    use ::UnOp::*;
    match *_i {
        Deref(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Not(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Neg(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
    }
}

pub fn visit_unsafety_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Unsafety) {
    use ::Unsafety::*;
    match *_i {
        Unsafe(ref mut _binding_0, ) => {
            tokens_helper(_visitor, &mut (_binding_0).0);
        }
        Normal => { }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_use_glob_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut UseGlob) {
    tokens_helper(_visitor, &mut (& mut _i . star_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_use_list_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut UseList) {
    tokens_helper(_visitor, &mut (& mut _i . brace_token).0);
    for mut el in & mut _i . items { let it = el.item_mut(); _visitor.visit_use_tree_mut(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_use_path_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut UsePath) {
    _visitor.visit_ident_mut(& mut _i . ident);
    if let Some(ref mut it) = _i . rename { 
            tokens_helper(_visitor, &mut (& mut ( it ) . 0).0);
            _visitor.visit_ident_mut(& mut ( it ) . 1);
         };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_use_tree_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut UseTree) {
    use ::UseTree::*;
    match *_i {
        Path(ref mut _binding_0, ) => {
            _visitor.visit_use_path_mut(_binding_0);
        }
        Glob(ref mut _binding_0, ) => {
            _visitor.visit_use_glob_mut(_binding_0);
        }
        List(ref mut _binding_0, ) => {
            _visitor.visit_use_list_mut(_binding_0);
        }
    }
}

pub fn visit_variant_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Variant) {
    _visitor.visit_ident_mut(& mut _i . ident);
    for it in & mut _i . attrs { _visitor.visit_attribute_mut(it) };
    _visitor.visit_variant_data_mut(& mut _i . data);
    if let Some(ref mut it) = _i . discriminant { _visitor.visit_expr_mut(it) };
    if let Some(ref mut it) = _i . eq_token { tokens_helper(_visitor, &mut (it).0) };
}

pub fn visit_variant_data_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut VariantData) {
    use ::VariantData::*;
    match *_i {
        Struct(ref mut _binding_0, ref mut _binding_1, ) => {
            for mut el in _binding_0 { let it = el.item_mut(); _visitor.visit_field_mut(it) };
            tokens_helper(_visitor, &mut (_binding_1).0);
        }
        Tuple(ref mut _binding_0, ref mut _binding_1, ) => {
            for mut el in _binding_0 { let it = el.item_mut(); _visitor.visit_field_mut(it) };
            tokens_helper(_visitor, &mut (_binding_1).0);
        }
        Unit => { }
    }
}

pub fn visit_vis_crate_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut VisCrate) {
    tokens_helper(_visitor, &mut (& mut _i . pub_token).0);
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
    tokens_helper(_visitor, &mut (& mut _i . crate_token).0);
}

pub fn visit_vis_inherited_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut VisInherited) {
}

pub fn visit_vis_public_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut VisPublic) {
    tokens_helper(_visitor, &mut (& mut _i . pub_token).0);
}

pub fn visit_vis_restricted_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut VisRestricted) {
    tokens_helper(_visitor, &mut (& mut _i . pub_token).0);
    tokens_helper(_visitor, &mut (& mut _i . paren_token).0);
    if let Some(ref mut it) = _i . in_token { tokens_helper(_visitor, &mut (it).0) };
    _visitor.visit_path_mut(& mut * _i . path);
}

pub fn visit_visibility_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut Visibility) {
    use ::Visibility::*;
    match *_i {
        Public(ref mut _binding_0, ) => {
            _visitor.visit_vis_public_mut(_binding_0);
        }
        Crate(ref mut _binding_0, ) => {
            _visitor.visit_vis_crate_mut(_binding_0);
        }
        Restricted(ref mut _binding_0, ) => {
            _visitor.visit_vis_restricted_mut(_binding_0);
        }
        Inherited(ref mut _binding_0, ) => {
            _visitor.visit_vis_inherited_mut(_binding_0);
        }
    }
}

pub fn visit_where_bound_predicate_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut WhereBoundPredicate) {
    if let Some(ref mut it) = _i . bound_lifetimes { _visitor.visit_bound_lifetimes_mut(it) };
    _visitor.visit_type_mut(& mut _i . bounded_ty);
    tokens_helper(_visitor, &mut (& mut _i . colon_token).0);
    for mut el in & mut _i . bounds { let it = el.item_mut(); _visitor.visit_type_param_bound_mut(it) };
}

pub fn visit_where_clause_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut WhereClause) {
    tokens_helper(_visitor, &mut (& mut _i . where_token).0);
    for mut el in & mut _i . predicates { let it = el.item_mut(); _visitor.visit_where_predicate_mut(it) };
}

pub fn visit_where_eq_predicate_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut WhereEqPredicate) {
    _visitor.visit_type_mut(& mut _i . lhs_ty);
    tokens_helper(_visitor, &mut (& mut _i . eq_token).0);
    _visitor.visit_type_mut(& mut _i . rhs_ty);
}

pub fn visit_where_predicate_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut WherePredicate) {
    use ::WherePredicate::*;
    match *_i {
        BoundPredicate(ref mut _binding_0, ) => {
            _visitor.visit_where_bound_predicate_mut(_binding_0);
        }
        RegionPredicate(ref mut _binding_0, ) => {
            _visitor.visit_where_region_predicate_mut(_binding_0);
        }
        EqPredicate(ref mut _binding_0, ) => {
            _visitor.visit_where_eq_predicate_mut(_binding_0);
        }
    }
}

pub fn visit_where_region_predicate_mut<V: VisitorMut + ?Sized>(_visitor: &mut V, _i: &mut WhereRegionPredicate) {
    _visitor.visit_lifetime_mut(& mut _i . lifetime);
    if let Some(ref mut it) = _i . colon_token { tokens_helper(_visitor, &mut (it).0) };
    for mut el in & mut _i . bounds { let it = el.item_mut(); _visitor.visit_lifetime_mut(it) };
}

