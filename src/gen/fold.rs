// THIS FILE IS AUTOMATICALLY GENERATED; DO NOT EDIT

//! A Folder represents an AST->AST fold; it accepts an AST piece,
//! and returns a piece of the same type.

#![cfg_attr(rustfmt, rustfmt_skip)]

// Unreachable code is generated sometimes without the full feature.
#![allow(unreachable_code)]
#![cfg_attr(feature = "cargo-clippy", allow(needless_pass_by_value))]

use *;
use token::{Brace, Bracket, Paren, Group};
use proc_macro2::Span;
use gen::helper::fold::*;


#[cfg(feature = "full")]
macro_rules! full {
    ($e:expr) => { $e }
}

#[cfg(not(feature = "full"))]
macro_rules! full {
    ($e:expr) => { unreachable!() }
}


/// AST->AST fold.
///
/// Each method of the Folder trait is a hook to be potentially overridden. Each
/// method's default implementation recursively visits the substructure of the
/// input via the `walk` functions, which perform an "identity fold", that
/// is, they return the same structure that they are given (for example the
/// `fold_file` method by default calls `fold::walk_file`).
///
/// If you want to ensure that your code handles every variant
/// explicitly, you need to override each method.  (And you also need
/// to monitor future changes to `Folder` in case a new method with a
/// new default implementation gets introduced.)
pub trait Folder {

fn fold_abi(&mut self, i: Abi) -> Abi { fold_abi(self, i) }

fn fold_abi_kind(&mut self, i: AbiKind) -> AbiKind { fold_abi_kind(self, i) }

fn fold_angle_bracketed_generic_arguments(&mut self, i: AngleBracketedGenericArguments) -> AngleBracketedGenericArguments { fold_angle_bracketed_generic_arguments(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_arg_captured(&mut self, i: ArgCaptured) -> ArgCaptured { fold_arg_captured(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_arg_self(&mut self, i: ArgSelf) -> ArgSelf { fold_arg_self(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_arg_self_ref(&mut self, i: ArgSelfRef) -> ArgSelfRef { fold_arg_self_ref(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_arm(&mut self, i: Arm) -> Arm { fold_arm(self, i) }

fn fold_attr_style(&mut self, i: AttrStyle) -> AttrStyle { fold_attr_style(self, i) }

fn fold_attribute(&mut self, i: Attribute) -> Attribute { fold_attribute(self, i) }

fn fold_bare_fn_arg(&mut self, i: BareFnArg) -> BareFnArg { fold_bare_fn_arg(self, i) }

fn fold_bare_fn_arg_name(&mut self, i: BareFnArgName) -> BareFnArgName { fold_bare_fn_arg_name(self, i) }

fn fold_bare_fn_type(&mut self, i: BareFnType) -> BareFnType { fold_bare_fn_type(self, i) }

fn fold_bin_op(&mut self, i: BinOp) -> BinOp { fold_bin_op(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_binding_mode(&mut self, i: BindingMode) -> BindingMode { fold_binding_mode(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_block(&mut self, i: Block) -> Block { fold_block(self, i) }

fn fold_body(&mut self, i: Body) -> Body { fold_body(self, i) }

fn fold_body_enum(&mut self, i: BodyEnum) -> BodyEnum { fold_body_enum(self, i) }

fn fold_body_struct(&mut self, i: BodyStruct) -> BodyStruct { fold_body_struct(self, i) }

fn fold_bound_lifetimes(&mut self, i: BoundLifetimes) -> BoundLifetimes { fold_bound_lifetimes(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_capture_by(&mut self, i: CaptureBy) -> CaptureBy { fold_capture_by(self, i) }

fn fold_const_param(&mut self, i: ConstParam) -> ConstParam { fold_const_param(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_constness(&mut self, i: Constness) -> Constness { fold_constness(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_defaultness(&mut self, i: Defaultness) -> Defaultness { fold_defaultness(self, i) }

fn fold_derive_input(&mut self, i: DeriveInput) -> DeriveInput { fold_derive_input(self, i) }

fn fold_expr(&mut self, i: Expr) -> Expr { fold_expr(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_addr_of(&mut self, i: ExprAddrOf) -> ExprAddrOf { fold_expr_addr_of(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_array(&mut self, i: ExprArray) -> ExprArray { fold_expr_array(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_assign(&mut self, i: ExprAssign) -> ExprAssign { fold_expr_assign(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_assign_op(&mut self, i: ExprAssignOp) -> ExprAssignOp { fold_expr_assign_op(self, i) }

fn fold_expr_binary(&mut self, i: ExprBinary) -> ExprBinary { fold_expr_binary(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_block(&mut self, i: ExprBlock) -> ExprBlock { fold_expr_block(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_box(&mut self, i: ExprBox) -> ExprBox { fold_expr_box(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_break(&mut self, i: ExprBreak) -> ExprBreak { fold_expr_break(self, i) }

fn fold_expr_call(&mut self, i: ExprCall) -> ExprCall { fold_expr_call(self, i) }

fn fold_expr_cast(&mut self, i: ExprCast) -> ExprCast { fold_expr_cast(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_catch(&mut self, i: ExprCatch) -> ExprCatch { fold_expr_catch(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_closure(&mut self, i: ExprClosure) -> ExprClosure { fold_expr_closure(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_continue(&mut self, i: ExprContinue) -> ExprContinue { fold_expr_continue(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_field(&mut self, i: ExprField) -> ExprField { fold_expr_field(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_for_loop(&mut self, i: ExprForLoop) -> ExprForLoop { fold_expr_for_loop(self, i) }

fn fold_expr_group(&mut self, i: ExprGroup) -> ExprGroup { fold_expr_group(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_if(&mut self, i: ExprIf) -> ExprIf { fold_expr_if(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_if_let(&mut self, i: ExprIfLet) -> ExprIfLet { fold_expr_if_let(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_in_place(&mut self, i: ExprInPlace) -> ExprInPlace { fold_expr_in_place(self, i) }

fn fold_expr_index(&mut self, i: ExprIndex) -> ExprIndex { fold_expr_index(self, i) }

fn fold_expr_kind(&mut self, i: ExprKind) -> ExprKind { fold_expr_kind(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_loop(&mut self, i: ExprLoop) -> ExprLoop { fold_expr_loop(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_match(&mut self, i: ExprMatch) -> ExprMatch { fold_expr_match(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_method_call(&mut self, i: ExprMethodCall) -> ExprMethodCall { fold_expr_method_call(self, i) }

fn fold_expr_paren(&mut self, i: ExprParen) -> ExprParen { fold_expr_paren(self, i) }

fn fold_expr_path(&mut self, i: ExprPath) -> ExprPath { fold_expr_path(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_range(&mut self, i: ExprRange) -> ExprRange { fold_expr_range(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_repeat(&mut self, i: ExprRepeat) -> ExprRepeat { fold_expr_repeat(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_ret(&mut self, i: ExprRet) -> ExprRet { fold_expr_ret(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_struct(&mut self, i: ExprStruct) -> ExprStruct { fold_expr_struct(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_try(&mut self, i: ExprTry) -> ExprTry { fold_expr_try(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_tuple(&mut self, i: ExprTuple) -> ExprTuple { fold_expr_tuple(self, i) }

fn fold_expr_type(&mut self, i: ExprType) -> ExprType { fold_expr_type(self, i) }

fn fold_expr_unary(&mut self, i: ExprUnary) -> ExprUnary { fold_expr_unary(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_unsafe(&mut self, i: ExprUnsafe) -> ExprUnsafe { fold_expr_unsafe(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_while(&mut self, i: ExprWhile) -> ExprWhile { fold_expr_while(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_while_let(&mut self, i: ExprWhileLet) -> ExprWhileLet { fold_expr_while_let(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_expr_yield(&mut self, i: ExprYield) -> ExprYield { fold_expr_yield(self, i) }

fn fold_field(&mut self, i: Field) -> Field { fold_field(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_field_pat(&mut self, i: FieldPat) -> FieldPat { fold_field_pat(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_field_value(&mut self, i: FieldValue) -> FieldValue { fold_field_value(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_file(&mut self, i: File) -> File { fold_file(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_fn_arg(&mut self, i: FnArg) -> FnArg { fold_fn_arg(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_fn_decl(&mut self, i: FnDecl) -> FnDecl { fold_fn_decl(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_foreign_item(&mut self, i: ForeignItem) -> ForeignItem { fold_foreign_item(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_foreign_item_fn(&mut self, i: ForeignItemFn) -> ForeignItemFn { fold_foreign_item_fn(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_foreign_item_static(&mut self, i: ForeignItemStatic) -> ForeignItemStatic { fold_foreign_item_static(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_foreign_item_type(&mut self, i: ForeignItemType) -> ForeignItemType { fold_foreign_item_type(self, i) }

fn fold_generic_argument(&mut self, i: GenericArgument) -> GenericArgument { fold_generic_argument(self, i) }

fn fold_generic_param(&mut self, i: GenericParam) -> GenericParam { fold_generic_param(self, i) }

fn fold_generics(&mut self, i: Generics) -> Generics { fold_generics(self, i) }

fn fold_ident(&mut self, i: Ident) -> Ident { fold_ident(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_impl_item(&mut self, i: ImplItem) -> ImplItem { fold_impl_item(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_impl_item_const(&mut self, i: ImplItemConst) -> ImplItemConst { fold_impl_item_const(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_impl_item_macro(&mut self, i: ImplItemMacro) -> ImplItemMacro { fold_impl_item_macro(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_impl_item_method(&mut self, i: ImplItemMethod) -> ImplItemMethod { fold_impl_item_method(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_impl_item_type(&mut self, i: ImplItemType) -> ImplItemType { fold_impl_item_type(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_impl_polarity(&mut self, i: ImplPolarity) -> ImplPolarity { fold_impl_polarity(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_in_place_kind(&mut self, i: InPlaceKind) -> InPlaceKind { fold_in_place_kind(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_index(&mut self, i: Index) -> Index { fold_index(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item(&mut self, i: Item) -> Item { fold_item(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_const(&mut self, i: ItemConst) -> ItemConst { fold_item_const(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_default_impl(&mut self, i: ItemDefaultImpl) -> ItemDefaultImpl { fold_item_default_impl(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_enum(&mut self, i: ItemEnum) -> ItemEnum { fold_item_enum(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_extern_crate(&mut self, i: ItemExternCrate) -> ItemExternCrate { fold_item_extern_crate(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_fn(&mut self, i: ItemFn) -> ItemFn { fold_item_fn(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_foreign_mod(&mut self, i: ItemForeignMod) -> ItemForeignMod { fold_item_foreign_mod(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_impl(&mut self, i: ItemImpl) -> ItemImpl { fold_item_impl(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_macro(&mut self, i: ItemMacro) -> ItemMacro { fold_item_macro(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_macro2(&mut self, i: ItemMacro2) -> ItemMacro2 { fold_item_macro2(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_mod(&mut self, i: ItemMod) -> ItemMod { fold_item_mod(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_static(&mut self, i: ItemStatic) -> ItemStatic { fold_item_static(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_struct(&mut self, i: ItemStruct) -> ItemStruct { fold_item_struct(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_trait(&mut self, i: ItemTrait) -> ItemTrait { fold_item_trait(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_type(&mut self, i: ItemType) -> ItemType { fold_item_type(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_union(&mut self, i: ItemUnion) -> ItemUnion { fold_item_union(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_use(&mut self, i: ItemUse) -> ItemUse { fold_item_use(self, i) }

fn fold_lifetime(&mut self, i: Lifetime) -> Lifetime { fold_lifetime(self, i) }

fn fold_lifetime_def(&mut self, i: LifetimeDef) -> LifetimeDef { fold_lifetime_def(self, i) }

fn fold_lit(&mut self, i: Lit) -> Lit { fold_lit(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_local(&mut self, i: Local) -> Local { fold_local(self, i) }

fn fold_macro(&mut self, i: Macro) -> Macro { fold_macro(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_member(&mut self, i: Member) -> Member { fold_member(self, i) }

fn fold_meta_item(&mut self, i: MetaItem) -> MetaItem { fold_meta_item(self, i) }

fn fold_meta_item_list(&mut self, i: MetaItemList) -> MetaItemList { fold_meta_item_list(self, i) }

fn fold_meta_name_value(&mut self, i: MetaNameValue) -> MetaNameValue { fold_meta_name_value(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_method_sig(&mut self, i: MethodSig) -> MethodSig { fold_method_sig(self, i) }

fn fold_mut_type(&mut self, i: MutType) -> MutType { fold_mut_type(self, i) }

fn fold_mutability(&mut self, i: Mutability) -> Mutability { fold_mutability(self, i) }

fn fold_nested_meta_item(&mut self, i: NestedMetaItem) -> NestedMetaItem { fold_nested_meta_item(self, i) }

fn fold_parenthesized_generic_arguments(&mut self, i: ParenthesizedGenericArguments) -> ParenthesizedGenericArguments { fold_parenthesized_generic_arguments(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_pat(&mut self, i: Pat) -> Pat { fold_pat(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_pat_box(&mut self, i: PatBox) -> PatBox { fold_pat_box(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_pat_ident(&mut self, i: PatIdent) -> PatIdent { fold_pat_ident(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_pat_lit(&mut self, i: PatLit) -> PatLit { fold_pat_lit(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_pat_path(&mut self, i: PatPath) -> PatPath { fold_pat_path(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_pat_range(&mut self, i: PatRange) -> PatRange { fold_pat_range(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_pat_ref(&mut self, i: PatRef) -> PatRef { fold_pat_ref(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_pat_slice(&mut self, i: PatSlice) -> PatSlice { fold_pat_slice(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_pat_struct(&mut self, i: PatStruct) -> PatStruct { fold_pat_struct(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_pat_tuple(&mut self, i: PatTuple) -> PatTuple { fold_pat_tuple(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_pat_tuple_struct(&mut self, i: PatTupleStruct) -> PatTupleStruct { fold_pat_tuple_struct(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_pat_wild(&mut self, i: PatWild) -> PatWild { fold_pat_wild(self, i) }

fn fold_path(&mut self, i: Path) -> Path { fold_path(self, i) }

fn fold_path_arguments(&mut self, i: PathArguments) -> PathArguments { fold_path_arguments(self, i) }

fn fold_path_segment(&mut self, i: PathSegment) -> PathSegment { fold_path_segment(self, i) }

fn fold_poly_trait_ref(&mut self, i: PolyTraitRef) -> PolyTraitRef { fold_poly_trait_ref(self, i) }

fn fold_qself(&mut self, i: QSelf) -> QSelf { fold_qself(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_range_limits(&mut self, i: RangeLimits) -> RangeLimits { fold_range_limits(self, i) }

fn fold_return_type(&mut self, i: ReturnType) -> ReturnType { fold_return_type(self, i) }

fn fold_span(&mut self, i: Span) -> Span { fold_span(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_stmt(&mut self, i: Stmt) -> Stmt { fold_stmt(self, i) }

fn fold_trait_bound_modifier(&mut self, i: TraitBoundModifier) -> TraitBoundModifier { fold_trait_bound_modifier(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_trait_item(&mut self, i: TraitItem) -> TraitItem { fold_trait_item(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_trait_item_const(&mut self, i: TraitItemConst) -> TraitItemConst { fold_trait_item_const(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_trait_item_macro(&mut self, i: TraitItemMacro) -> TraitItemMacro { fold_trait_item_macro(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_trait_item_method(&mut self, i: TraitItemMethod) -> TraitItemMethod { fold_trait_item_method(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_trait_item_type(&mut self, i: TraitItemType) -> TraitItemType { fold_trait_item_type(self, i) }

fn fold_type(&mut self, i: Type) -> Type { fold_type(self, i) }

fn fold_type_array(&mut self, i: TypeArray) -> TypeArray { fold_type_array(self, i) }

fn fold_type_bare_fn(&mut self, i: TypeBareFn) -> TypeBareFn { fold_type_bare_fn(self, i) }

fn fold_type_binding(&mut self, i: TypeBinding) -> TypeBinding { fold_type_binding(self, i) }

fn fold_type_group(&mut self, i: TypeGroup) -> TypeGroup { fold_type_group(self, i) }

fn fold_type_impl_trait(&mut self, i: TypeImplTrait) -> TypeImplTrait { fold_type_impl_trait(self, i) }

fn fold_type_infer(&mut self, i: TypeInfer) -> TypeInfer { fold_type_infer(self, i) }

fn fold_type_never(&mut self, i: TypeNever) -> TypeNever { fold_type_never(self, i) }

fn fold_type_param(&mut self, i: TypeParam) -> TypeParam { fold_type_param(self, i) }

fn fold_type_param_bound(&mut self, i: TypeParamBound) -> TypeParamBound { fold_type_param_bound(self, i) }

fn fold_type_paren(&mut self, i: TypeParen) -> TypeParen { fold_type_paren(self, i) }

fn fold_type_path(&mut self, i: TypePath) -> TypePath { fold_type_path(self, i) }

fn fold_type_ptr(&mut self, i: TypePtr) -> TypePtr { fold_type_ptr(self, i) }

fn fold_type_reference(&mut self, i: TypeReference) -> TypeReference { fold_type_reference(self, i) }

fn fold_type_slice(&mut self, i: TypeSlice) -> TypeSlice { fold_type_slice(self, i) }

fn fold_type_trait_object(&mut self, i: TypeTraitObject) -> TypeTraitObject { fold_type_trait_object(self, i) }

fn fold_type_tuple(&mut self, i: TypeTuple) -> TypeTuple { fold_type_tuple(self, i) }

fn fold_un_op(&mut self, i: UnOp) -> UnOp { fold_un_op(self, i) }

fn fold_unsafety(&mut self, i: Unsafety) -> Unsafety { fold_unsafety(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_use_glob(&mut self, i: UseGlob) -> UseGlob { fold_use_glob(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_use_list(&mut self, i: UseList) -> UseList { fold_use_list(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_use_path(&mut self, i: UsePath) -> UsePath { fold_use_path(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_use_tree(&mut self, i: UseTree) -> UseTree { fold_use_tree(self, i) }

fn fold_variant(&mut self, i: Variant) -> Variant { fold_variant(self, i) }

fn fold_variant_data(&mut self, i: VariantData) -> VariantData { fold_variant_data(self, i) }

fn fold_vis_crate(&mut self, i: VisCrate) -> VisCrate { fold_vis_crate(self, i) }

fn fold_vis_inherited(&mut self, i: VisInherited) -> VisInherited { fold_vis_inherited(self, i) }

fn fold_vis_public(&mut self, i: VisPublic) -> VisPublic { fold_vis_public(self, i) }

fn fold_vis_restricted(&mut self, i: VisRestricted) -> VisRestricted { fold_vis_restricted(self, i) }

fn fold_visibility(&mut self, i: Visibility) -> Visibility { fold_visibility(self, i) }

fn fold_where_bound_predicate(&mut self, i: WhereBoundPredicate) -> WhereBoundPredicate { fold_where_bound_predicate(self, i) }

fn fold_where_clause(&mut self, i: WhereClause) -> WhereClause { fold_where_clause(self, i) }

fn fold_where_eq_predicate(&mut self, i: WhereEqPredicate) -> WhereEqPredicate { fold_where_eq_predicate(self, i) }

fn fold_where_predicate(&mut self, i: WherePredicate) -> WherePredicate { fold_where_predicate(self, i) }

fn fold_where_region_predicate(&mut self, i: WhereRegionPredicate) -> WhereRegionPredicate { fold_where_region_predicate(self, i) }

}


pub fn fold_abi<V: Folder + ?Sized>(_visitor: &mut V, _i: Abi) -> Abi {
    Abi {
        extern_token: Token ! [ extern ](tokens_helper(_visitor, &(_i . extern_token).0)),
        kind: _visitor.fold_abi_kind(_i . kind),
    }
}

pub fn fold_abi_kind<V: Folder + ?Sized>(_visitor: &mut V, _i: AbiKind) -> AbiKind {
    use ::AbiKind::*;
    match _i {
        Named(_binding_0, ) => {
            Named (
                _visitor.fold_lit(_binding_0),
            )
        }
        Default => { Default }
    }
}

pub fn fold_angle_bracketed_generic_arguments<V: Folder + ?Sized>(_visitor: &mut V, _i: AngleBracketedGenericArguments) -> AngleBracketedGenericArguments {
    AngleBracketedGenericArguments {
        turbofish: (_i . turbofish).map(|it| { Token ! [ :: ](tokens_helper(_visitor, &(it).0)) }),
        lt_token: Token ! [ < ](tokens_helper(_visitor, &(_i . lt_token).0)),
        args: FoldHelper::lift(_i . args, |it| { _visitor.fold_generic_argument(it) }),
        gt_token: Token ! [ > ](tokens_helper(_visitor, &(_i . gt_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_arg_captured<V: Folder + ?Sized>(_visitor: &mut V, _i: ArgCaptured) -> ArgCaptured {
    ArgCaptured {
        pat: _visitor.fold_pat(_i . pat),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: _visitor.fold_type(_i . ty),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_arg_self<V: Folder + ?Sized>(_visitor: &mut V, _i: ArgSelf) -> ArgSelf {
    ArgSelf {
        mutbl: _visitor.fold_mutability(_i . mutbl),
        self_token: Token ! [ self ](tokens_helper(_visitor, &(_i . self_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_arg_self_ref<V: Folder + ?Sized>(_visitor: &mut V, _i: ArgSelfRef) -> ArgSelfRef {
    ArgSelfRef {
        and_token: Token ! [ & ](tokens_helper(_visitor, &(_i . and_token).0)),
        self_token: Token ! [ self ](tokens_helper(_visitor, &(_i . self_token).0)),
        lifetime: (_i . lifetime).map(|it| { _visitor.fold_lifetime(it) }),
        mutbl: _visitor.fold_mutability(_i . mutbl),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_arm<V: Folder + ?Sized>(_visitor: &mut V, _i: Arm) -> Arm {
    Arm {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        pats: FoldHelper::lift(_i . pats, |it| { _visitor.fold_pat(it) }),
        if_token: (_i . if_token).map(|it| { Token ! [ if ](tokens_helper(_visitor, &(it).0)) }),
        guard: (_i . guard).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
        rocket_token: Token ! [ => ](tokens_helper(_visitor, &(_i . rocket_token).0)),
        body: Box::new(_visitor.fold_expr(* _i . body)),
        comma: (_i . comma).map(|it| { Token ! [ , ](tokens_helper(_visitor, &(it).0)) }),
    }
}

pub fn fold_attr_style<V: Folder + ?Sized>(_visitor: &mut V, _i: AttrStyle) -> AttrStyle {
    use ::AttrStyle::*;
    match _i {
        Outer => { Outer }
        Inner(_binding_0, ) => {
            Inner (
                Token ! [ ! ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}

pub fn fold_attribute<V: Folder + ?Sized>(_visitor: &mut V, _i: Attribute) -> Attribute {
    Attribute {
        style: _visitor.fold_attr_style(_i . style),
        pound_token: Token ! [ # ](tokens_helper(_visitor, &(_i . pound_token).0)),
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
        path: _visitor.fold_path(_i . path),
        tts: _i . tts,
        is_sugared_doc: _i . is_sugared_doc,
    }
}

pub fn fold_bare_fn_arg<V: Folder + ?Sized>(_visitor: &mut V, _i: BareFnArg) -> BareFnArg {
    BareFnArg {
        name: (_i . name).map(|it| { (
            _visitor.fold_bare_fn_arg_name(( it ) . 0),
            Token ! [ : ](tokens_helper(_visitor, &(( it ) . 1).0)),
        ) }),
        ty: _visitor.fold_type(_i . ty),
    }
}

pub fn fold_bare_fn_arg_name<V: Folder + ?Sized>(_visitor: &mut V, _i: BareFnArgName) -> BareFnArgName {
    use ::BareFnArgName::*;
    match _i {
        Named(_binding_0, ) => {
            Named (
                _visitor.fold_ident(_binding_0),
            )
        }
        Wild(_binding_0, ) => {
            Wild (
                Token ! [ _ ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}

pub fn fold_bare_fn_type<V: Folder + ?Sized>(_visitor: &mut V, _i: BareFnType) -> BareFnType {
    BareFnType {
        lifetimes: (_i . lifetimes).map(|it| { _visitor.fold_bound_lifetimes(it) }),
        unsafety: _visitor.fold_unsafety(_i . unsafety),
        abi: (_i . abi).map(|it| { _visitor.fold_abi(it) }),
        fn_token: Token ! [ fn ](tokens_helper(_visitor, &(_i . fn_token).0)),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        inputs: FoldHelper::lift(_i . inputs, |it| { _visitor.fold_bare_fn_arg(it) }),
        variadic: (_i . variadic).map(|it| { Token ! [ ... ](tokens_helper(_visitor, &(it).0)) }),
        output: _visitor.fold_return_type(_i . output),
    }
}

pub fn fold_bin_op<V: Folder + ?Sized>(_visitor: &mut V, _i: BinOp) -> BinOp {
    use ::BinOp::*;
    match _i {
        Add(_binding_0, ) => {
            Add (
                Token ! [ + ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Sub(_binding_0, ) => {
            Sub (
                Token ! [ - ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Mul(_binding_0, ) => {
            Mul (
                Token ! [ * ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Div(_binding_0, ) => {
            Div (
                Token ! [ / ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Rem(_binding_0, ) => {
            Rem (
                Token ! [ % ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        And(_binding_0, ) => {
            And (
                Token ! [ && ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Or(_binding_0, ) => {
            Or (
                Token ! [ || ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BitXor(_binding_0, ) => {
            BitXor (
                Token ! [ ^ ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BitAnd(_binding_0, ) => {
            BitAnd (
                Token ! [ & ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BitOr(_binding_0, ) => {
            BitOr (
                Token ! [ | ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Shl(_binding_0, ) => {
            Shl (
                Token ! [ << ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Shr(_binding_0, ) => {
            Shr (
                Token ! [ >> ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Eq(_binding_0, ) => {
            Eq (
                Token ! [ == ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Lt(_binding_0, ) => {
            Lt (
                Token ! [ < ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Le(_binding_0, ) => {
            Le (
                Token ! [ <= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Ne(_binding_0, ) => {
            Ne (
                Token ! [ != ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Ge(_binding_0, ) => {
            Ge (
                Token ! [ >= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Gt(_binding_0, ) => {
            Gt (
                Token ! [ > ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        AddEq(_binding_0, ) => {
            AddEq (
                Token ! [ += ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        SubEq(_binding_0, ) => {
            SubEq (
                Token ! [ -= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        MulEq(_binding_0, ) => {
            MulEq (
                Token ! [ *= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        DivEq(_binding_0, ) => {
            DivEq (
                Token ! [ /= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        RemEq(_binding_0, ) => {
            RemEq (
                Token ! [ %= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BitXorEq(_binding_0, ) => {
            BitXorEq (
                Token ! [ ^= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BitAndEq(_binding_0, ) => {
            BitAndEq (
                Token ! [ &= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BitOrEq(_binding_0, ) => {
            BitOrEq (
                Token ! [ |= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        ShlEq(_binding_0, ) => {
            ShlEq (
                Token ! [ <<= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        ShrEq(_binding_0, ) => {
            ShrEq (
                Token ! [ >>= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_binding_mode<V: Folder + ?Sized>(_visitor: &mut V, _i: BindingMode) -> BindingMode {
    use ::BindingMode::*;
    match _i {
        ByRef(_binding_0, _binding_1, ) => {
            ByRef (
                Token ! [ ref ](tokens_helper(_visitor, &(_binding_0).0)),
                _visitor.fold_mutability(_binding_1),
            )
        }
        ByValue(_binding_0, ) => {
            ByValue (
                _visitor.fold_mutability(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_block<V: Folder + ?Sized>(_visitor: &mut V, _i: Block) -> Block {
    Block {
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        stmts: FoldHelper::lift(_i . stmts, |it| { _visitor.fold_stmt(it) }),
    }
}

pub fn fold_body<V: Folder + ?Sized>(_visitor: &mut V, _i: Body) -> Body {
    use ::Body::*;
    match _i {
        Enum(_binding_0, ) => {
            Enum (
                _visitor.fold_body_enum(_binding_0),
            )
        }
        Struct(_binding_0, ) => {
            Struct (
                _visitor.fold_body_struct(_binding_0),
            )
        }
    }
}

pub fn fold_body_enum<V: Folder + ?Sized>(_visitor: &mut V, _i: BodyEnum) -> BodyEnum {
    BodyEnum {
        enum_token: Token ! [ enum ](tokens_helper(_visitor, &(_i . enum_token).0)),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        variants: FoldHelper::lift(_i . variants, |it| { _visitor.fold_variant(it) }),
    }
}

pub fn fold_body_struct<V: Folder + ?Sized>(_visitor: &mut V, _i: BodyStruct) -> BodyStruct {
    BodyStruct {
        data: _visitor.fold_variant_data(_i . data),
        struct_token: Token ! [ struct ](tokens_helper(_visitor, &(_i . struct_token).0)),
        semi_token: (_i . semi_token).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}

pub fn fold_bound_lifetimes<V: Folder + ?Sized>(_visitor: &mut V, _i: BoundLifetimes) -> BoundLifetimes {
    BoundLifetimes {
        for_token: Token ! [ for ](tokens_helper(_visitor, &(_i . for_token).0)),
        lt_token: Token ! [ < ](tokens_helper(_visitor, &(_i . lt_token).0)),
        lifetimes: FoldHelper::lift(_i . lifetimes, |it| { _visitor.fold_lifetime_def(it) }),
        gt_token: Token ! [ > ](tokens_helper(_visitor, &(_i . gt_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_capture_by<V: Folder + ?Sized>(_visitor: &mut V, _i: CaptureBy) -> CaptureBy {
    use ::CaptureBy::*;
    match _i {
        Value(_binding_0, ) => {
            Value (
                Token ! [ move ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Ref => { Ref }
    }
}

pub fn fold_const_param<V: Folder + ?Sized>(_visitor: &mut V, _i: ConstParam) -> ConstParam {
    ConstParam {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        const_token: Token ! [ const ](tokens_helper(_visitor, &(_i . const_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: _visitor.fold_type(_i . ty),
        eq_token: (_i . eq_token).map(|it| { Token ! [ = ](tokens_helper(_visitor, &(it).0)) }),
        default: (_i . default).map(|it| { _visitor.fold_expr(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_constness<V: Folder + ?Sized>(_visitor: &mut V, _i: Constness) -> Constness {
    use ::Constness::*;
    match _i {
        Const(_binding_0, ) => {
            Const (
                Token ! [ const ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        NotConst => { NotConst }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_defaultness<V: Folder + ?Sized>(_visitor: &mut V, _i: Defaultness) -> Defaultness {
    use ::Defaultness::*;
    match _i {
        Default(_binding_0, ) => {
            Default (
                Token ! [ default ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Final => { Final }
    }
}

pub fn fold_derive_input<V: Folder + ?Sized>(_visitor: &mut V, _i: DeriveInput) -> DeriveInput {
    DeriveInput {
        ident: _visitor.fold_ident(_i . ident),
        vis: _visitor.fold_visibility(_i . vis),
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        generics: _visitor.fold_generics(_i . generics),
        body: _visitor.fold_body(_i . body),
    }
}

pub fn fold_expr<V: Folder + ?Sized>(_visitor: &mut V, _i: Expr) -> Expr {
    Expr {
        node: _visitor.fold_expr_kind(_i . node),
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_addr_of<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprAddrOf) -> ExprAddrOf {
    ExprAddrOf {
        and_token: Token ! [ & ](tokens_helper(_visitor, &(_i . and_token).0)),
        mutbl: _visitor.fold_mutability(_i . mutbl),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_array<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprArray) -> ExprArray {
    ExprArray {
        exprs: FoldHelper::lift(_i . exprs, |it| { _visitor.fold_expr(it) }),
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_assign<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprAssign) -> ExprAssign {
    ExprAssign {
        left: Box::new(_visitor.fold_expr(* _i . left)),
        right: Box::new(_visitor.fold_expr(* _i . right)),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_assign_op<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprAssignOp) -> ExprAssignOp {
    ExprAssignOp {
        op: _visitor.fold_bin_op(_i . op),
        left: Box::new(_visitor.fold_expr(* _i . left)),
        right: Box::new(_visitor.fold_expr(* _i . right)),
    }
}

pub fn fold_expr_binary<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprBinary) -> ExprBinary {
    ExprBinary {
        op: _visitor.fold_bin_op(_i . op),
        left: Box::new(_visitor.fold_expr(* _i . left)),
        right: Box::new(_visitor.fold_expr(* _i . right)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_block<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprBlock) -> ExprBlock {
    ExprBlock {
        block: _visitor.fold_block(_i . block),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_box<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprBox) -> ExprBox {
    ExprBox {
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        box_token: Token ! [ box ](tokens_helper(_visitor, &(_i . box_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_break<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprBreak) -> ExprBreak {
    ExprBreak {
        label: (_i . label).map(|it| { _visitor.fold_lifetime(it) }),
        expr: (_i . expr).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
        break_token: Token ! [ break ](tokens_helper(_visitor, &(_i . break_token).0)),
    }
}

pub fn fold_expr_call<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprCall) -> ExprCall {
    ExprCall {
        func: Box::new(_visitor.fold_expr(* _i . func)),
        args: FoldHelper::lift(_i . args, |it| { _visitor.fold_expr(it) }),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
    }
}

pub fn fold_expr_cast<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprCast) -> ExprCast {
    ExprCast {
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        as_token: Token ! [ as ](tokens_helper(_visitor, &(_i . as_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_catch<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprCatch) -> ExprCatch {
    ExprCatch {
        do_token: Token ! [ do ](tokens_helper(_visitor, &(_i . do_token).0)),
        catch_token: Token ! [ catch ](tokens_helper(_visitor, &(_i . catch_token).0)),
        block: _visitor.fold_block(_i . block),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_closure<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprClosure) -> ExprClosure {
    ExprClosure {
        capture: _visitor.fold_capture_by(_i . capture),
        or1_token: Token ! [ | ](tokens_helper(_visitor, &(_i . or1_token).0)),
        inputs: FoldHelper::lift(_i . inputs, |it| { _visitor.fold_fn_arg(it) }),
        or2_token: Token ! [ | ](tokens_helper(_visitor, &(_i . or2_token).0)),
        output: _visitor.fold_return_type(_i . output),
        body: Box::new(_visitor.fold_expr(* _i . body)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_continue<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprContinue) -> ExprContinue {
    ExprContinue {
        label: (_i . label).map(|it| { _visitor.fold_lifetime(it) }),
        continue_token: Token ! [ continue ](tokens_helper(_visitor, &(_i . continue_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_field<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprField) -> ExprField {
    ExprField {
        base: Box::new(_visitor.fold_expr(* _i . base)),
        dot_token: Token ! [ . ](tokens_helper(_visitor, &(_i . dot_token).0)),
        member: _visitor.fold_member(_i . member),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_for_loop<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprForLoop) -> ExprForLoop {
    ExprForLoop {
        pat: Box::new(_visitor.fold_pat(* _i . pat)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        body: _visitor.fold_block(_i . body),
        label: (_i . label).map(|it| { _visitor.fold_lifetime(it) }),
        for_token: Token ! [ for ](tokens_helper(_visitor, &(_i . for_token).0)),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        in_token: Token ! [ in ](tokens_helper(_visitor, &(_i . in_token).0)),
    }
}

pub fn fold_expr_group<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprGroup) -> ExprGroup {
    ExprGroup {
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        group_token: Group(tokens_helper(_visitor, &(_i . group_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_if<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprIf) -> ExprIf {
    ExprIf {
        cond: Box::new(_visitor.fold_expr(* _i . cond)),
        if_true: _visitor.fold_block(_i . if_true),
        if_false: (_i . if_false).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
        if_token: Token ! [ if ](tokens_helper(_visitor, &(_i . if_token).0)),
        else_token: (_i . else_token).map(|it| { Token ! [ else ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_if_let<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprIfLet) -> ExprIfLet {
    ExprIfLet {
        pat: Box::new(_visitor.fold_pat(* _i . pat)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        if_true: _visitor.fold_block(_i . if_true),
        if_false: (_i . if_false).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
        if_token: Token ! [ if ](tokens_helper(_visitor, &(_i . if_token).0)),
        let_token: Token ! [ let ](tokens_helper(_visitor, &(_i . let_token).0)),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        else_token: (_i . else_token).map(|it| { Token ! [ else ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_in_place<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprInPlace) -> ExprInPlace {
    ExprInPlace {
        place: Box::new(_visitor.fold_expr(* _i . place)),
        kind: _visitor.fold_in_place_kind(_i . kind),
        value: Box::new(_visitor.fold_expr(* _i . value)),
    }
}

pub fn fold_expr_index<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprIndex) -> ExprIndex {
    ExprIndex {
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        index: Box::new(_visitor.fold_expr(* _i . index)),
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
    }
}

pub fn fold_expr_kind<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprKind) -> ExprKind {
    use ::ExprKind::*;
    match _i {
        Box(_binding_0, ) => {
            Box (
                full!(_visitor.fold_expr_box(_binding_0)),
            )
        }
        InPlace(_binding_0, ) => {
            InPlace (
                full!(_visitor.fold_expr_in_place(_binding_0)),
            )
        }
        Array(_binding_0, ) => {
            Array (
                full!(_visitor.fold_expr_array(_binding_0)),
            )
        }
        Call(_binding_0, ) => {
            Call (
                _visitor.fold_expr_call(_binding_0),
            )
        }
        MethodCall(_binding_0, ) => {
            MethodCall (
                full!(_visitor.fold_expr_method_call(_binding_0)),
            )
        }
        Tuple(_binding_0, ) => {
            Tuple (
                full!(_visitor.fold_expr_tuple(_binding_0)),
            )
        }
        Binary(_binding_0, ) => {
            Binary (
                _visitor.fold_expr_binary(_binding_0),
            )
        }
        Unary(_binding_0, ) => {
            Unary (
                _visitor.fold_expr_unary(_binding_0),
            )
        }
        Lit(_binding_0, ) => {
            Lit (
                _visitor.fold_lit(_binding_0),
            )
        }
        Cast(_binding_0, ) => {
            Cast (
                _visitor.fold_expr_cast(_binding_0),
            )
        }
        Type(_binding_0, ) => {
            Type (
                _visitor.fold_expr_type(_binding_0),
            )
        }
        If(_binding_0, ) => {
            If (
                full!(_visitor.fold_expr_if(_binding_0)),
            )
        }
        IfLet(_binding_0, ) => {
            IfLet (
                full!(_visitor.fold_expr_if_let(_binding_0)),
            )
        }
        While(_binding_0, ) => {
            While (
                full!(_visitor.fold_expr_while(_binding_0)),
            )
        }
        WhileLet(_binding_0, ) => {
            WhileLet (
                full!(_visitor.fold_expr_while_let(_binding_0)),
            )
        }
        ForLoop(_binding_0, ) => {
            ForLoop (
                full!(_visitor.fold_expr_for_loop(_binding_0)),
            )
        }
        Loop(_binding_0, ) => {
            Loop (
                full!(_visitor.fold_expr_loop(_binding_0)),
            )
        }
        Match(_binding_0, ) => {
            Match (
                full!(_visitor.fold_expr_match(_binding_0)),
            )
        }
        Closure(_binding_0, ) => {
            Closure (
                full!(_visitor.fold_expr_closure(_binding_0)),
            )
        }
        Unsafe(_binding_0, ) => {
            Unsafe (
                full!(_visitor.fold_expr_unsafe(_binding_0)),
            )
        }
        Block(_binding_0, ) => {
            Block (
                full!(_visitor.fold_expr_block(_binding_0)),
            )
        }
        Assign(_binding_0, ) => {
            Assign (
                full!(_visitor.fold_expr_assign(_binding_0)),
            )
        }
        AssignOp(_binding_0, ) => {
            AssignOp (
                full!(_visitor.fold_expr_assign_op(_binding_0)),
            )
        }
        Field(_binding_0, ) => {
            Field (
                full!(_visitor.fold_expr_field(_binding_0)),
            )
        }
        Index(_binding_0, ) => {
            Index (
                _visitor.fold_expr_index(_binding_0),
            )
        }
        Range(_binding_0, ) => {
            Range (
                full!(_visitor.fold_expr_range(_binding_0)),
            )
        }
        Path(_binding_0, ) => {
            Path (
                _visitor.fold_expr_path(_binding_0),
            )
        }
        AddrOf(_binding_0, ) => {
            AddrOf (
                full!(_visitor.fold_expr_addr_of(_binding_0)),
            )
        }
        Break(_binding_0, ) => {
            Break (
                full!(_visitor.fold_expr_break(_binding_0)),
            )
        }
        Continue(_binding_0, ) => {
            Continue (
                full!(_visitor.fold_expr_continue(_binding_0)),
            )
        }
        Ret(_binding_0, ) => {
            Ret (
                full!(_visitor.fold_expr_ret(_binding_0)),
            )
        }
        Macro(_binding_0, ) => {
            Macro (
                _visitor.fold_macro(_binding_0),
            )
        }
        Struct(_binding_0, ) => {
            Struct (
                full!(_visitor.fold_expr_struct(_binding_0)),
            )
        }
        Repeat(_binding_0, ) => {
            Repeat (
                full!(_visitor.fold_expr_repeat(_binding_0)),
            )
        }
        Paren(_binding_0, ) => {
            Paren (
                _visitor.fold_expr_paren(_binding_0),
            )
        }
        Group(_binding_0, ) => {
            Group (
                _visitor.fold_expr_group(_binding_0),
            )
        }
        Try(_binding_0, ) => {
            Try (
                full!(_visitor.fold_expr_try(_binding_0)),
            )
        }
        Catch(_binding_0, ) => {
            Catch (
                full!(_visitor.fold_expr_catch(_binding_0)),
            )
        }
        Yield(_binding_0, ) => {
            Yield (
                full!(_visitor.fold_expr_yield(_binding_0)),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_loop<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprLoop) -> ExprLoop {
    ExprLoop {
        body: _visitor.fold_block(_i . body),
        label: (_i . label).map(|it| { _visitor.fold_lifetime(it) }),
        loop_token: Token ! [ loop ](tokens_helper(_visitor, &(_i . loop_token).0)),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_match<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprMatch) -> ExprMatch {
    ExprMatch {
        match_token: Token ! [ match ](tokens_helper(_visitor, &(_i . match_token).0)),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        arms: FoldHelper::lift(_i . arms, |it| { _visitor.fold_arm(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_method_call<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprMethodCall) -> ExprMethodCall {
    ExprMethodCall {
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        method: _visitor.fold_ident(_i . method),
        typarams: FoldHelper::lift(_i . typarams, |it| { _visitor.fold_type(it) }),
        args: FoldHelper::lift(_i . args, |it| { _visitor.fold_expr(it) }),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        dot_token: Token ! [ . ](tokens_helper(_visitor, &(_i . dot_token).0)),
        lt_token: (_i . lt_token).map(|it| { Token ! [ < ](tokens_helper(_visitor, &(it).0)) }),
        colon2_token: (_i . colon2_token).map(|it| { Token ! [ :: ](tokens_helper(_visitor, &(it).0)) }),
        gt_token: (_i . gt_token).map(|it| { Token ! [ > ](tokens_helper(_visitor, &(it).0)) }),
    }
}

pub fn fold_expr_paren<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprParen) -> ExprParen {
    ExprParen {
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
    }
}

pub fn fold_expr_path<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprPath) -> ExprPath {
    ExprPath {
        qself: (_i . qself).map(|it| { _visitor.fold_qself(it) }),
        path: _visitor.fold_path(_i . path),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_range<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprRange) -> ExprRange {
    ExprRange {
        from: (_i . from).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
        to: (_i . to).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
        limits: _visitor.fold_range_limits(_i . limits),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_repeat<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprRepeat) -> ExprRepeat {
    ExprRepeat {
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        amt: Box::new(_visitor.fold_expr(* _i . amt)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_ret<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprRet) -> ExprRet {
    ExprRet {
        expr: (_i . expr).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
        return_token: Token ! [ return ](tokens_helper(_visitor, &(_i . return_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_struct<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprStruct) -> ExprStruct {
    ExprStruct {
        path: _visitor.fold_path(_i . path),
        fields: FoldHelper::lift(_i . fields, |it| { _visitor.fold_field_value(it) }),
        rest: (_i . rest).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
        dot2_token: (_i . dot2_token).map(|it| { Token ! [ .. ](tokens_helper(_visitor, &(it).0)) }),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_try<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprTry) -> ExprTry {
    ExprTry {
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        question_token: Token ! [ ? ](tokens_helper(_visitor, &(_i . question_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_tuple<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprTuple) -> ExprTuple {
    ExprTuple {
        args: FoldHelper::lift(_i . args, |it| { _visitor.fold_expr(it) }),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
    }
}

pub fn fold_expr_type<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprType) -> ExprType {
    ExprType {
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
    }
}

pub fn fold_expr_unary<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprUnary) -> ExprUnary {
    ExprUnary {
        op: _visitor.fold_un_op(_i . op),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_unsafe<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprUnsafe) -> ExprUnsafe {
    ExprUnsafe {
        unsafe_token: Token ! [ unsafe ](tokens_helper(_visitor, &(_i . unsafe_token).0)),
        block: _visitor.fold_block(_i . block),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_while<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprWhile) -> ExprWhile {
    ExprWhile {
        cond: Box::new(_visitor.fold_expr(* _i . cond)),
        body: _visitor.fold_block(_i . body),
        label: (_i . label).map(|it| { _visitor.fold_lifetime(it) }),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        while_token: Token ! [ while ](tokens_helper(_visitor, &(_i . while_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_while_let<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprWhileLet) -> ExprWhileLet {
    ExprWhileLet {
        pat: Box::new(_visitor.fold_pat(* _i . pat)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        body: _visitor.fold_block(_i . body),
        label: (_i . label).map(|it| { _visitor.fold_lifetime(it) }),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        while_token: Token ! [ while ](tokens_helper(_visitor, &(_i . while_token).0)),
        let_token: Token ! [ let ](tokens_helper(_visitor, &(_i . let_token).0)),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_expr_yield<V: Folder + ?Sized>(_visitor: &mut V, _i: ExprYield) -> ExprYield {
    ExprYield {
        yield_token: Token ! [ yield ](tokens_helper(_visitor, &(_i . yield_token).0)),
        expr: (_i . expr).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
    }
}

pub fn fold_field<V: Folder + ?Sized>(_visitor: &mut V, _i: Field) -> Field {
    Field {
        ident: (_i . ident).map(|it| { _visitor.fold_ident(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        ty: _visitor.fold_type(_i . ty),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_field_pat<V: Folder + ?Sized>(_visitor: &mut V, _i: FieldPat) -> FieldPat {
    FieldPat {
        member: _visitor.fold_member(_i . member),
        pat: Box::new(_visitor.fold_pat(* _i . pat)),
        is_shorthand: _i . is_shorthand,
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_field_value<V: Folder + ?Sized>(_visitor: &mut V, _i: FieldValue) -> FieldValue {
    FieldValue {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        member: _visitor.fold_member(_i . member),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        expr: _visitor.fold_expr(_i . expr),
        is_shorthand: _i . is_shorthand,
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_file<V: Folder + ?Sized>(_visitor: &mut V, _i: File) -> File {
    File {
        shebang: _i . shebang,
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        items: FoldHelper::lift(_i . items, |it| { _visitor.fold_item(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_fn_arg<V: Folder + ?Sized>(_visitor: &mut V, _i: FnArg) -> FnArg {
    use ::FnArg::*;
    match _i {
        SelfRef(_binding_0, ) => {
            SelfRef (
                _visitor.fold_arg_self_ref(_binding_0),
            )
        }
        SelfValue(_binding_0, ) => {
            SelfValue (
                _visitor.fold_arg_self(_binding_0),
            )
        }
        Captured(_binding_0, ) => {
            Captured (
                _visitor.fold_arg_captured(_binding_0),
            )
        }
        Inferred(_binding_0, ) => {
            Inferred (
                _visitor.fold_pat(_binding_0),
            )
        }
        Ignored(_binding_0, ) => {
            Ignored (
                _visitor.fold_type(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_fn_decl<V: Folder + ?Sized>(_visitor: &mut V, _i: FnDecl) -> FnDecl {
    FnDecl {
        fn_token: Token ! [ fn ](tokens_helper(_visitor, &(_i . fn_token).0)),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        inputs: FoldHelper::lift(_i . inputs, |it| { _visitor.fold_fn_arg(it) }),
        output: _visitor.fold_return_type(_i . output),
        generics: _visitor.fold_generics(_i . generics),
        variadic: (_i . variadic).map(|it| { Token ! [ ... ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_foreign_item<V: Folder + ?Sized>(_visitor: &mut V, _i: ForeignItem) -> ForeignItem {
    use ::ForeignItem::*;
    match _i {
        Fn(_binding_0, ) => {
            Fn (
                _visitor.fold_foreign_item_fn(_binding_0),
            )
        }
        Static(_binding_0, ) => {
            Static (
                _visitor.fold_foreign_item_static(_binding_0),
            )
        }
        Type(_binding_0, ) => {
            Type (
                _visitor.fold_foreign_item_type(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_foreign_item_fn<V: Folder + ?Sized>(_visitor: &mut V, _i: ForeignItemFn) -> ForeignItemFn {
    ForeignItemFn {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        ident: _visitor.fold_ident(_i . ident),
        decl: Box::new(_visitor.fold_fn_decl(* _i . decl)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_foreign_item_static<V: Folder + ?Sized>(_visitor: &mut V, _i: ForeignItemStatic) -> ForeignItemStatic {
    ForeignItemStatic {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        static_token: Token ! [ static ](tokens_helper(_visitor, &(_i . static_token).0)),
        mutbl: _visitor.fold_mutability(_i . mutbl),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_foreign_item_type<V: Folder + ?Sized>(_visitor: &mut V, _i: ForeignItemType) -> ForeignItemType {
    ForeignItemType {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        type_token: Token ! [ type ](tokens_helper(_visitor, &(_i . type_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}

pub fn fold_generic_argument<V: Folder + ?Sized>(_visitor: &mut V, _i: GenericArgument) -> GenericArgument {
    use ::GenericArgument::*;
    match _i {
        Lifetime(_binding_0, ) => {
            Lifetime (
                _visitor.fold_lifetime(_binding_0),
            )
        }
        Type(_binding_0, ) => {
            Type (
                _visitor.fold_type(_binding_0),
            )
        }
        TypeBinding(_binding_0, ) => {
            TypeBinding (
                _visitor.fold_type_binding(_binding_0),
            )
        }
        Const(_binding_0, ) => {
            Const (
                _visitor.fold_expr(_binding_0),
            )
        }
    }
}

pub fn fold_generic_param<V: Folder + ?Sized>(_visitor: &mut V, _i: GenericParam) -> GenericParam {
    use ::GenericParam::*;
    match _i {
        Lifetime(_binding_0, ) => {
            Lifetime (
                _visitor.fold_lifetime_def(_binding_0),
            )
        }
        Type(_binding_0, ) => {
            Type (
                _visitor.fold_type_param(_binding_0),
            )
        }
        Const(_binding_0, ) => {
            Const (
                _visitor.fold_const_param(_binding_0),
            )
        }
    }
}

pub fn fold_generics<V: Folder + ?Sized>(_visitor: &mut V, _i: Generics) -> Generics {
    Generics {
        lt_token: (_i . lt_token).map(|it| { Token ! [ < ](tokens_helper(_visitor, &(it).0)) }),
        params: FoldHelper::lift(_i . params, |it| { _visitor.fold_generic_param(it) }),
        gt_token: (_i . gt_token).map(|it| { Token ! [ > ](tokens_helper(_visitor, &(it).0)) }),
        where_clause: (_i . where_clause).map(|it| { _visitor.fold_where_clause(it) }),
    }
}

pub fn fold_ident<V: Folder + ?Sized>(_visitor: &mut V, _i: Ident) -> Ident {
    Ident {
        sym: _i . sym,
        span: _visitor.fold_span(_i . span),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_impl_item<V: Folder + ?Sized>(_visitor: &mut V, _i: ImplItem) -> ImplItem {
    use ::ImplItem::*;
    match _i {
        Const(_binding_0, ) => {
            Const (
                _visitor.fold_impl_item_const(_binding_0),
            )
        }
        Method(_binding_0, ) => {
            Method (
                _visitor.fold_impl_item_method(_binding_0),
            )
        }
        Type(_binding_0, ) => {
            Type (
                _visitor.fold_impl_item_type(_binding_0),
            )
        }
        Macro(_binding_0, ) => {
            Macro (
                _visitor.fold_impl_item_macro(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_impl_item_const<V: Folder + ?Sized>(_visitor: &mut V, _i: ImplItemConst) -> ImplItemConst {
    ImplItemConst {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        defaultness: _visitor.fold_defaultness(_i . defaultness),
        const_token: Token ! [ const ](tokens_helper(_visitor, &(_i . const_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: _visitor.fold_type(_i . ty),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        expr: _visitor.fold_expr(_i . expr),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_impl_item_macro<V: Folder + ?Sized>(_visitor: &mut V, _i: ImplItemMacro) -> ImplItemMacro {
    ImplItemMacro {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        mac: _visitor.fold_macro(_i . mac),
        semi_token: (_i . semi_token).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_impl_item_method<V: Folder + ?Sized>(_visitor: &mut V, _i: ImplItemMethod) -> ImplItemMethod {
    ImplItemMethod {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        defaultness: _visitor.fold_defaultness(_i . defaultness),
        sig: _visitor.fold_method_sig(_i . sig),
        block: _visitor.fold_block(_i . block),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_impl_item_type<V: Folder + ?Sized>(_visitor: &mut V, _i: ImplItemType) -> ImplItemType {
    ImplItemType {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        defaultness: _visitor.fold_defaultness(_i . defaultness),
        type_token: Token ! [ type ](tokens_helper(_visitor, &(_i . type_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        ty: _visitor.fold_type(_i . ty),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_impl_polarity<V: Folder + ?Sized>(_visitor: &mut V, _i: ImplPolarity) -> ImplPolarity {
    use ::ImplPolarity::*;
    match _i {
        Positive => { Positive }
        Negative(_binding_0, ) => {
            Negative (
                Token ! [ ! ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_in_place_kind<V: Folder + ?Sized>(_visitor: &mut V, _i: InPlaceKind) -> InPlaceKind {
    use ::InPlaceKind::*;
    match _i {
        Arrow(_binding_0, ) => {
            Arrow (
                Token ! [ <- ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        In(_binding_0, ) => {
            In (
                Token ! [ in ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_index<V: Folder + ?Sized>(_visitor: &mut V, _i: Index) -> Index {
    Index {
        index: _i . index,
        span: _visitor.fold_span(_i . span),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item<V: Folder + ?Sized>(_visitor: &mut V, _i: Item) -> Item {
    use ::Item::*;
    match _i {
        ExternCrate(_binding_0, ) => {
            ExternCrate (
                _visitor.fold_item_extern_crate(_binding_0),
            )
        }
        Use(_binding_0, ) => {
            Use (
                _visitor.fold_item_use(_binding_0),
            )
        }
        Static(_binding_0, ) => {
            Static (
                _visitor.fold_item_static(_binding_0),
            )
        }
        Const(_binding_0, ) => {
            Const (
                _visitor.fold_item_const(_binding_0),
            )
        }
        Fn(_binding_0, ) => {
            Fn (
                _visitor.fold_item_fn(_binding_0),
            )
        }
        Mod(_binding_0, ) => {
            Mod (
                _visitor.fold_item_mod(_binding_0),
            )
        }
        ForeignMod(_binding_0, ) => {
            ForeignMod (
                _visitor.fold_item_foreign_mod(_binding_0),
            )
        }
        Type(_binding_0, ) => {
            Type (
                _visitor.fold_item_type(_binding_0),
            )
        }
        Enum(_binding_0, ) => {
            Enum (
                _visitor.fold_item_enum(_binding_0),
            )
        }
        Struct(_binding_0, ) => {
            Struct (
                _visitor.fold_item_struct(_binding_0),
            )
        }
        Union(_binding_0, ) => {
            Union (
                _visitor.fold_item_union(_binding_0),
            )
        }
        Trait(_binding_0, ) => {
            Trait (
                _visitor.fold_item_trait(_binding_0),
            )
        }
        DefaultImpl(_binding_0, ) => {
            DefaultImpl (
                _visitor.fold_item_default_impl(_binding_0),
            )
        }
        Impl(_binding_0, ) => {
            Impl (
                _visitor.fold_item_impl(_binding_0),
            )
        }
        Macro(_binding_0, ) => {
            Macro (
                _visitor.fold_item_macro(_binding_0),
            )
        }
        Macro2(_binding_0, ) => {
            Macro2 (
                _visitor.fold_item_macro2(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_const<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemConst) -> ItemConst {
    ItemConst {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        const_token: Token ! [ const ](tokens_helper(_visitor, &(_i . const_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_default_impl<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemDefaultImpl) -> ItemDefaultImpl {
    ItemDefaultImpl {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        unsafety: _visitor.fold_unsafety(_i . unsafety),
        impl_token: Token ! [ impl ](tokens_helper(_visitor, &(_i . impl_token).0)),
        path: _visitor.fold_path(_i . path),
        for_token: Token ! [ for ](tokens_helper(_visitor, &(_i . for_token).0)),
        dot2_token: Token ! [ .. ](tokens_helper(_visitor, &(_i . dot2_token).0)),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_enum<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemEnum) -> ItemEnum {
    ItemEnum {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        enum_token: Token ! [ enum ](tokens_helper(_visitor, &(_i . enum_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        variants: FoldHelper::lift(_i . variants, |it| { _visitor.fold_variant(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_extern_crate<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemExternCrate) -> ItemExternCrate {
    ItemExternCrate {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        extern_token: Token ! [ extern ](tokens_helper(_visitor, &(_i . extern_token).0)),
        crate_token: Token ! [ crate ](tokens_helper(_visitor, &(_i . crate_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        rename: (_i . rename).map(|it| { (
            Token ! [ as ](tokens_helper(_visitor, &(( it ) . 0).0)),
            _visitor.fold_ident(( it ) . 1),
        ) }),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_fn<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemFn) -> ItemFn {
    ItemFn {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        constness: _visitor.fold_constness(_i . constness),
        unsafety: _visitor.fold_unsafety(_i . unsafety),
        abi: (_i . abi).map(|it| { _visitor.fold_abi(it) }),
        decl: Box::new(_visitor.fold_fn_decl(* _i . decl)),
        ident: _visitor.fold_ident(_i . ident),
        block: Box::new(_visitor.fold_block(* _i . block)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_foreign_mod<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemForeignMod) -> ItemForeignMod {
    ItemForeignMod {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        abi: _visitor.fold_abi(_i . abi),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        items: FoldHelper::lift(_i . items, |it| { _visitor.fold_foreign_item(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_impl<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemImpl) -> ItemImpl {
    ItemImpl {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        defaultness: _visitor.fold_defaultness(_i . defaultness),
        unsafety: _visitor.fold_unsafety(_i . unsafety),
        impl_token: Token ! [ impl ](tokens_helper(_visitor, &(_i . impl_token).0)),
        generics: _visitor.fold_generics(_i . generics),
        trait_: (_i . trait_).map(|it| { (
            _visitor.fold_impl_polarity(( it ) . 0),
            _visitor.fold_path(( it ) . 1),
            Token ! [ for ](tokens_helper(_visitor, &(( it ) . 2).0)),
        ) }),
        self_ty: Box::new(_visitor.fold_type(* _i . self_ty)),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        items: FoldHelper::lift(_i . items, |it| { _visitor.fold_impl_item(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_macro<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemMacro) -> ItemMacro {
    ItemMacro {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        ident: (_i . ident).map(|it| { _visitor.fold_ident(it) }),
        mac: _visitor.fold_macro(_i . mac),
        semi_token: (_i . semi_token).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_macro2<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemMacro2) -> ItemMacro2 {
    ItemMacro2 {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        macro_token: Token ! [ macro ](tokens_helper(_visitor, &(_i . macro_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        args: _i . args,
        body: _i . body,
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_mod<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemMod) -> ItemMod {
    ItemMod {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        mod_token: Token ! [ mod ](tokens_helper(_visitor, &(_i . mod_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        content: (_i . content).map(|it| { (
            Brace(tokens_helper(_visitor, &(( it ) . 0).0)),
            FoldHelper::lift(( it ) . 1, |it| { _visitor.fold_item(it) }),
        ) }),
        semi: (_i . semi).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_static<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemStatic) -> ItemStatic {
    ItemStatic {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        static_token: Token ! [ static ](tokens_helper(_visitor, &(_i . static_token).0)),
        mutbl: _visitor.fold_mutability(_i . mutbl),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_struct<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemStruct) -> ItemStruct {
    ItemStruct {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        struct_token: Token ! [ struct ](tokens_helper(_visitor, &(_i . struct_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        data: _visitor.fold_variant_data(_i . data),
        semi_token: (_i . semi_token).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_trait<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemTrait) -> ItemTrait {
    ItemTrait {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        unsafety: _visitor.fold_unsafety(_i . unsafety),
        auto_token: (_i . auto_token).map(|it| { Token ! [ auto ](tokens_helper(_visitor, &(it).0)) }),
        trait_token: Token ! [ trait ](tokens_helper(_visitor, &(_i . trait_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        supertraits: FoldHelper::lift(_i . supertraits, |it| { _visitor.fold_type_param_bound(it) }),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        items: FoldHelper::lift(_i . items, |it| { _visitor.fold_trait_item(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_type<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemType) -> ItemType {
    ItemType {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        type_token: Token ! [ type ](tokens_helper(_visitor, &(_i . type_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_union<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemUnion) -> ItemUnion {
    ItemUnion {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        union_token: Token ! [ union ](tokens_helper(_visitor, &(_i . union_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        data: _visitor.fold_variant_data(_i . data),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_use<V: Folder + ?Sized>(_visitor: &mut V, _i: ItemUse) -> ItemUse {
    ItemUse {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        use_token: Token ! [ use ](tokens_helper(_visitor, &(_i . use_token).0)),
        leading_colon: (_i . leading_colon).map(|it| { Token ! [ :: ](tokens_helper(_visitor, &(it).0)) }),
        prefix: FoldHelper::lift(_i . prefix, |it| { _visitor.fold_ident(it) }),
        tree: _visitor.fold_use_tree(_i . tree),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}

pub fn fold_lifetime<V: Folder + ?Sized>(_visitor: &mut V, _i: Lifetime) -> Lifetime {
    Lifetime {
        sym: _i . sym,
        span: _visitor.fold_span(_i . span),
    }
}

pub fn fold_lifetime_def<V: Folder + ?Sized>(_visitor: &mut V, _i: LifetimeDef) -> LifetimeDef {
    LifetimeDef {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        lifetime: _visitor.fold_lifetime(_i . lifetime),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_lifetime(it) }),
    }
}

pub fn fold_lit<V: Folder + ?Sized>(_visitor: &mut V, _i: Lit) -> Lit {
    Lit {
        value: _i . value,
        span: _visitor.fold_span(_i . span),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_local<V: Folder + ?Sized>(_visitor: &mut V, _i: Local) -> Local {
    Local {
        let_token: Token ! [ let ](tokens_helper(_visitor, &(_i . let_token).0)),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        eq_token: (_i . eq_token).map(|it| { Token ! [ = ](tokens_helper(_visitor, &(it).0)) }),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
        pat: Box::new(_visitor.fold_pat(* _i . pat)),
        ty: (_i . ty).map(|it| { Box::new(_visitor.fold_type(* it)) }),
        init: (_i . init).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
    }
}

pub fn fold_macro<V: Folder + ?Sized>(_visitor: &mut V, _i: Macro) -> Macro {
    Macro {
        path: _visitor.fold_path(_i . path),
        bang_token: Token ! [ ! ](tokens_helper(_visitor, &(_i . bang_token).0)),
        tokens: _i . tokens,
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_member<V: Folder + ?Sized>(_visitor: &mut V, _i: Member) -> Member {
    use ::Member::*;
    match _i {
        Named(_binding_0, ) => {
            Named (
                _visitor.fold_ident(_binding_0),
            )
        }
        Unnamed(_binding_0, ) => {
            Unnamed (
                _visitor.fold_index(_binding_0),
            )
        }
    }
}

pub fn fold_meta_item<V: Folder + ?Sized>(_visitor: &mut V, _i: MetaItem) -> MetaItem {
    use ::MetaItem::*;
    match _i {
        Term(_binding_0, ) => {
            Term (
                _visitor.fold_ident(_binding_0),
            )
        }
        List(_binding_0, ) => {
            List (
                _visitor.fold_meta_item_list(_binding_0),
            )
        }
        NameValue(_binding_0, ) => {
            NameValue (
                _visitor.fold_meta_name_value(_binding_0),
            )
        }
    }
}

pub fn fold_meta_item_list<V: Folder + ?Sized>(_visitor: &mut V, _i: MetaItemList) -> MetaItemList {
    MetaItemList {
        ident: _visitor.fold_ident(_i . ident),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        nested: FoldHelper::lift(_i . nested, |it| { _visitor.fold_nested_meta_item(it) }),
    }
}

pub fn fold_meta_name_value<V: Folder + ?Sized>(_visitor: &mut V, _i: MetaNameValue) -> MetaNameValue {
    MetaNameValue {
        ident: _visitor.fold_ident(_i . ident),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        lit: _visitor.fold_lit(_i . lit),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_method_sig<V: Folder + ?Sized>(_visitor: &mut V, _i: MethodSig) -> MethodSig {
    MethodSig {
        constness: _visitor.fold_constness(_i . constness),
        unsafety: _visitor.fold_unsafety(_i . unsafety),
        abi: (_i . abi).map(|it| { _visitor.fold_abi(it) }),
        ident: _visitor.fold_ident(_i . ident),
        decl: _visitor.fold_fn_decl(_i . decl),
    }
}

pub fn fold_mut_type<V: Folder + ?Sized>(_visitor: &mut V, _i: MutType) -> MutType {
    MutType {
        ty: _visitor.fold_type(_i . ty),
        mutability: _visitor.fold_mutability(_i . mutability),
    }
}

pub fn fold_mutability<V: Folder + ?Sized>(_visitor: &mut V, _i: Mutability) -> Mutability {
    use ::Mutability::*;
    match _i {
        Mutable(_binding_0, ) => {
            Mutable (
                Token ! [ mut ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Immutable => { Immutable }
    }
}

pub fn fold_nested_meta_item<V: Folder + ?Sized>(_visitor: &mut V, _i: NestedMetaItem) -> NestedMetaItem {
    use ::NestedMetaItem::*;
    match _i {
        MetaItem(_binding_0, ) => {
            MetaItem (
                _visitor.fold_meta_item(_binding_0),
            )
        }
        Literal(_binding_0, ) => {
            Literal (
                _visitor.fold_lit(_binding_0),
            )
        }
    }
}

pub fn fold_parenthesized_generic_arguments<V: Folder + ?Sized>(_visitor: &mut V, _i: ParenthesizedGenericArguments) -> ParenthesizedGenericArguments {
    ParenthesizedGenericArguments {
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        inputs: FoldHelper::lift(_i . inputs, |it| { _visitor.fold_type(it) }),
        output: _visitor.fold_return_type(_i . output),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_pat<V: Folder + ?Sized>(_visitor: &mut V, _i: Pat) -> Pat {
    use ::Pat::*;
    match _i {
        Wild(_binding_0, ) => {
            Wild (
                _visitor.fold_pat_wild(_binding_0),
            )
        }
        Ident(_binding_0, ) => {
            Ident (
                _visitor.fold_pat_ident(_binding_0),
            )
        }
        Struct(_binding_0, ) => {
            Struct (
                _visitor.fold_pat_struct(_binding_0),
            )
        }
        TupleStruct(_binding_0, ) => {
            TupleStruct (
                _visitor.fold_pat_tuple_struct(_binding_0),
            )
        }
        Path(_binding_0, ) => {
            Path (
                _visitor.fold_pat_path(_binding_0),
            )
        }
        Tuple(_binding_0, ) => {
            Tuple (
                _visitor.fold_pat_tuple(_binding_0),
            )
        }
        Box(_binding_0, ) => {
            Box (
                _visitor.fold_pat_box(_binding_0),
            )
        }
        Ref(_binding_0, ) => {
            Ref (
                _visitor.fold_pat_ref(_binding_0),
            )
        }
        Lit(_binding_0, ) => {
            Lit (
                _visitor.fold_pat_lit(_binding_0),
            )
        }
        Range(_binding_0, ) => {
            Range (
                _visitor.fold_pat_range(_binding_0),
            )
        }
        Slice(_binding_0, ) => {
            Slice (
                _visitor.fold_pat_slice(_binding_0),
            )
        }
        Macro(_binding_0, ) => {
            Macro (
                _visitor.fold_macro(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_pat_box<V: Folder + ?Sized>(_visitor: &mut V, _i: PatBox) -> PatBox {
    PatBox {
        pat: Box::new(_visitor.fold_pat(* _i . pat)),
        box_token: Token ! [ box ](tokens_helper(_visitor, &(_i . box_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_pat_ident<V: Folder + ?Sized>(_visitor: &mut V, _i: PatIdent) -> PatIdent {
    PatIdent {
        mode: _visitor.fold_binding_mode(_i . mode),
        ident: _visitor.fold_ident(_i . ident),
        subpat: (_i . subpat).map(|it| { Box::new(_visitor.fold_pat(* it)) }),
        at_token: (_i . at_token).map(|it| { Token ! [ @ ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_pat_lit<V: Folder + ?Sized>(_visitor: &mut V, _i: PatLit) -> PatLit {
    PatLit {
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_pat_path<V: Folder + ?Sized>(_visitor: &mut V, _i: PatPath) -> PatPath {
    PatPath {
        qself: (_i . qself).map(|it| { _visitor.fold_qself(it) }),
        path: _visitor.fold_path(_i . path),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_pat_range<V: Folder + ?Sized>(_visitor: &mut V, _i: PatRange) -> PatRange {
    PatRange {
        lo: Box::new(_visitor.fold_expr(* _i . lo)),
        hi: Box::new(_visitor.fold_expr(* _i . hi)),
        limits: _visitor.fold_range_limits(_i . limits),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_pat_ref<V: Folder + ?Sized>(_visitor: &mut V, _i: PatRef) -> PatRef {
    PatRef {
        pat: Box::new(_visitor.fold_pat(* _i . pat)),
        mutbl: _visitor.fold_mutability(_i . mutbl),
        and_token: Token ! [ & ](tokens_helper(_visitor, &(_i . and_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_pat_slice<V: Folder + ?Sized>(_visitor: &mut V, _i: PatSlice) -> PatSlice {
    PatSlice {
        front: FoldHelper::lift(_i . front, |it| { _visitor.fold_pat(it) }),
        middle: (_i . middle).map(|it| { Box::new(_visitor.fold_pat(* it)) }),
        back: FoldHelper::lift(_i . back, |it| { _visitor.fold_pat(it) }),
        dot2_token: (_i . dot2_token).map(|it| { Token ! [ .. ](tokens_helper(_visitor, &(it).0)) }),
        comma_token: (_i . comma_token).map(|it| { Token ! [ , ](tokens_helper(_visitor, &(it).0)) }),
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_pat_struct<V: Folder + ?Sized>(_visitor: &mut V, _i: PatStruct) -> PatStruct {
    PatStruct {
        path: _visitor.fold_path(_i . path),
        fields: FoldHelper::lift(_i . fields, |it| { _visitor.fold_field_pat(it) }),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        dot2_token: (_i . dot2_token).map(|it| { Token ! [ .. ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_pat_tuple<V: Folder + ?Sized>(_visitor: &mut V, _i: PatTuple) -> PatTuple {
    PatTuple {
        pats: FoldHelper::lift(_i . pats, |it| { _visitor.fold_pat(it) }),
        dots_pos: _i . dots_pos,
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        dot2_token: (_i . dot2_token).map(|it| { Token ! [ .. ](tokens_helper(_visitor, &(it).0)) }),
        comma_token: (_i . comma_token).map(|it| { Token ! [ , ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_pat_tuple_struct<V: Folder + ?Sized>(_visitor: &mut V, _i: PatTupleStruct) -> PatTupleStruct {
    PatTupleStruct {
        path: _visitor.fold_path(_i . path),
        pat: _visitor.fold_pat_tuple(_i . pat),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_pat_wild<V: Folder + ?Sized>(_visitor: &mut V, _i: PatWild) -> PatWild {
    PatWild {
        underscore_token: Token ! [ _ ](tokens_helper(_visitor, &(_i . underscore_token).0)),
    }
}

pub fn fold_path<V: Folder + ?Sized>(_visitor: &mut V, _i: Path) -> Path {
    Path {
        leading_colon: (_i . leading_colon).map(|it| { Token ! [ :: ](tokens_helper(_visitor, &(it).0)) }),
        segments: FoldHelper::lift(_i . segments, |it| { _visitor.fold_path_segment(it) }),
    }
}

pub fn fold_path_arguments<V: Folder + ?Sized>(_visitor: &mut V, _i: PathArguments) -> PathArguments {
    use ::PathArguments::*;
    match _i {
        None => { None }
        AngleBracketed(_binding_0, ) => {
            AngleBracketed (
                _visitor.fold_angle_bracketed_generic_arguments(_binding_0),
            )
        }
        Parenthesized(_binding_0, ) => {
            Parenthesized (
                _visitor.fold_parenthesized_generic_arguments(_binding_0),
            )
        }
    }
}

pub fn fold_path_segment<V: Folder + ?Sized>(_visitor: &mut V, _i: PathSegment) -> PathSegment {
    PathSegment {
        ident: _visitor.fold_ident(_i . ident),
        arguments: _visitor.fold_path_arguments(_i . arguments),
    }
}

pub fn fold_poly_trait_ref<V: Folder + ?Sized>(_visitor: &mut V, _i: PolyTraitRef) -> PolyTraitRef {
    PolyTraitRef {
        bound_lifetimes: (_i . bound_lifetimes).map(|it| { _visitor.fold_bound_lifetimes(it) }),
        trait_ref: _visitor.fold_path(_i . trait_ref),
    }
}

pub fn fold_qself<V: Folder + ?Sized>(_visitor: &mut V, _i: QSelf) -> QSelf {
    QSelf {
        lt_token: Token ! [ < ](tokens_helper(_visitor, &(_i . lt_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
        position: _i . position,
        as_token: (_i . as_token).map(|it| { Token ! [ as ](tokens_helper(_visitor, &(it).0)) }),
        gt_token: Token ! [ > ](tokens_helper(_visitor, &(_i . gt_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_range_limits<V: Folder + ?Sized>(_visitor: &mut V, _i: RangeLimits) -> RangeLimits {
    use ::RangeLimits::*;
    match _i {
        HalfOpen(_binding_0, ) => {
            HalfOpen (
                Token ! [ .. ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Closed(_binding_0, ) => {
            Closed (
                Token ! [ ..= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}

pub fn fold_return_type<V: Folder + ?Sized>(_visitor: &mut V, _i: ReturnType) -> ReturnType {
    use ::ReturnType::*;
    match _i {
        Default => { Default }
        Type(_binding_0, _binding_1, ) => {
            Type (
                Box::new(_visitor.fold_type(* _binding_0)),
                Token ! [ -> ](tokens_helper(_visitor, &(_binding_1).0)),
            )
        }
    }
}

pub fn fold_span<V: Folder + ?Sized>(_visitor: &mut V, _i: Span) -> Span {
    _i
}
# [ cfg ( feature = "full" ) ]
pub fn fold_stmt<V: Folder + ?Sized>(_visitor: &mut V, _i: Stmt) -> Stmt {
    use ::Stmt::*;
    match _i {
        Local(_binding_0, ) => {
            Local (
                Box::new(_visitor.fold_local(* _binding_0)),
            )
        }
        Item(_binding_0, ) => {
            Item (
                Box::new(_visitor.fold_item(* _binding_0)),
            )
        }
        Expr(_binding_0, ) => {
            Expr (
                Box::new(_visitor.fold_expr(* _binding_0)),
            )
        }
        Semi(_binding_0, _binding_1, ) => {
            Semi (
                Box::new(_visitor.fold_expr(* _binding_0)),
                Token ! [ ; ](tokens_helper(_visitor, &(_binding_1).0)),
            )
        }
    }
}

pub fn fold_trait_bound_modifier<V: Folder + ?Sized>(_visitor: &mut V, _i: TraitBoundModifier) -> TraitBoundModifier {
    use ::TraitBoundModifier::*;
    match _i {
        None => { None }
        Maybe(_binding_0, ) => {
            Maybe (
                Token ! [ ? ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_trait_item<V: Folder + ?Sized>(_visitor: &mut V, _i: TraitItem) -> TraitItem {
    use ::TraitItem::*;
    match _i {
        Const(_binding_0, ) => {
            Const (
                _visitor.fold_trait_item_const(_binding_0),
            )
        }
        Method(_binding_0, ) => {
            Method (
                _visitor.fold_trait_item_method(_binding_0),
            )
        }
        Type(_binding_0, ) => {
            Type (
                _visitor.fold_trait_item_type(_binding_0),
            )
        }
        Macro(_binding_0, ) => {
            Macro (
                _visitor.fold_trait_item_macro(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_trait_item_const<V: Folder + ?Sized>(_visitor: &mut V, _i: TraitItemConst) -> TraitItemConst {
    TraitItemConst {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        const_token: Token ! [ const ](tokens_helper(_visitor, &(_i . const_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: _visitor.fold_type(_i . ty),
        default: (_i . default).map(|it| { (
            Token ! [ = ](tokens_helper(_visitor, &(( it ) . 0).0)),
            _visitor.fold_expr(( it ) . 1),
        ) }),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_trait_item_macro<V: Folder + ?Sized>(_visitor: &mut V, _i: TraitItemMacro) -> TraitItemMacro {
    TraitItemMacro {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        mac: _visitor.fold_macro(_i . mac),
        semi_token: (_i . semi_token).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_trait_item_method<V: Folder + ?Sized>(_visitor: &mut V, _i: TraitItemMethod) -> TraitItemMethod {
    TraitItemMethod {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        sig: _visitor.fold_method_sig(_i . sig),
        default: (_i . default).map(|it| { _visitor.fold_block(it) }),
        semi_token: (_i . semi_token).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_trait_item_type<V: Folder + ?Sized>(_visitor: &mut V, _i: TraitItemType) -> TraitItemType {
    TraitItemType {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        type_token: Token ! [ type ](tokens_helper(_visitor, &(_i . type_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_type_param_bound(it) }),
        default: (_i . default).map(|it| { (
            Token ! [ = ](tokens_helper(_visitor, &(( it ) . 0).0)),
            _visitor.fold_type(( it ) . 1),
        ) }),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}

pub fn fold_type<V: Folder + ?Sized>(_visitor: &mut V, _i: Type) -> Type {
    use ::Type::*;
    match _i {
        Slice(_binding_0, ) => {
            Slice (
                _visitor.fold_type_slice(_binding_0),
            )
        }
        Array(_binding_0, ) => {
            Array (
                _visitor.fold_type_array(_binding_0),
            )
        }
        Ptr(_binding_0, ) => {
            Ptr (
                _visitor.fold_type_ptr(_binding_0),
            )
        }
        Reference(_binding_0, ) => {
            Reference (
                _visitor.fold_type_reference(_binding_0),
            )
        }
        BareFn(_binding_0, ) => {
            BareFn (
                _visitor.fold_type_bare_fn(_binding_0),
            )
        }
        Never(_binding_0, ) => {
            Never (
                _visitor.fold_type_never(_binding_0),
            )
        }
        Tuple(_binding_0, ) => {
            Tuple (
                _visitor.fold_type_tuple(_binding_0),
            )
        }
        Path(_binding_0, ) => {
            Path (
                _visitor.fold_type_path(_binding_0),
            )
        }
        TraitObject(_binding_0, ) => {
            TraitObject (
                _visitor.fold_type_trait_object(_binding_0),
            )
        }
        ImplTrait(_binding_0, ) => {
            ImplTrait (
                _visitor.fold_type_impl_trait(_binding_0),
            )
        }
        Paren(_binding_0, ) => {
            Paren (
                _visitor.fold_type_paren(_binding_0),
            )
        }
        Group(_binding_0, ) => {
            Group (
                _visitor.fold_type_group(_binding_0),
            )
        }
        Infer(_binding_0, ) => {
            Infer (
                _visitor.fold_type_infer(_binding_0),
            )
        }
        Macro(_binding_0, ) => {
            Macro (
                _visitor.fold_macro(_binding_0),
            )
        }
    }
}

pub fn fold_type_array<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeArray) -> TypeArray {
    TypeArray {
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
        amt: _visitor.fold_expr(_i . amt),
    }
}

pub fn fold_type_bare_fn<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeBareFn) -> TypeBareFn {
    TypeBareFn {
        ty: Box::new(_visitor.fold_bare_fn_type(* _i . ty)),
    }
}

pub fn fold_type_binding<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeBinding) -> TypeBinding {
    TypeBinding {
        ident: _visitor.fold_ident(_i . ident),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        ty: _visitor.fold_type(_i . ty),
    }
}

pub fn fold_type_group<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeGroup) -> TypeGroup {
    TypeGroup {
        group_token: Group(tokens_helper(_visitor, &(_i . group_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
    }
}

pub fn fold_type_impl_trait<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeImplTrait) -> TypeImplTrait {
    TypeImplTrait {
        impl_token: Token ! [ impl ](tokens_helper(_visitor, &(_i . impl_token).0)),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_type_param_bound(it) }),
    }
}

pub fn fold_type_infer<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeInfer) -> TypeInfer {
    TypeInfer {
        underscore_token: Token ! [ _ ](tokens_helper(_visitor, &(_i . underscore_token).0)),
    }
}

pub fn fold_type_never<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeNever) -> TypeNever {
    TypeNever {
        bang_token: Token ! [ ! ](tokens_helper(_visitor, &(_i . bang_token).0)),
    }
}

pub fn fold_type_param<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeParam) -> TypeParam {
    TypeParam {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_type_param_bound(it) }),
        eq_token: (_i . eq_token).map(|it| { Token ! [ = ](tokens_helper(_visitor, &(it).0)) }),
        default: (_i . default).map(|it| { _visitor.fold_type(it) }),
    }
}

pub fn fold_type_param_bound<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeParamBound) -> TypeParamBound {
    use ::TypeParamBound::*;
    match _i {
        Trait(_binding_0, _binding_1, ) => {
            Trait (
                _visitor.fold_poly_trait_ref(_binding_0),
                _visitor.fold_trait_bound_modifier(_binding_1),
            )
        }
        Region(_binding_0, ) => {
            Region (
                _visitor.fold_lifetime(_binding_0),
            )
        }
    }
}

pub fn fold_type_paren<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeParen) -> TypeParen {
    TypeParen {
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
    }
}

pub fn fold_type_path<V: Folder + ?Sized>(_visitor: &mut V, _i: TypePath) -> TypePath {
    TypePath {
        qself: (_i . qself).map(|it| { _visitor.fold_qself(it) }),
        path: _visitor.fold_path(_i . path),
    }
}

pub fn fold_type_ptr<V: Folder + ?Sized>(_visitor: &mut V, _i: TypePtr) -> TypePtr {
    TypePtr {
        star_token: Token ! [ * ](tokens_helper(_visitor, &(_i . star_token).0)),
        const_token: (_i . const_token).map(|it| { Token ! [ const ](tokens_helper(_visitor, &(it).0)) }),
        ty: Box::new(_visitor.fold_mut_type(* _i . ty)),
    }
}

pub fn fold_type_reference<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeReference) -> TypeReference {
    TypeReference {
        and_token: Token ! [ & ](tokens_helper(_visitor, &(_i . and_token).0)),
        lifetime: (_i . lifetime).map(|it| { _visitor.fold_lifetime(it) }),
        ty: Box::new(_visitor.fold_mut_type(* _i . ty)),
    }
}

pub fn fold_type_slice<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeSlice) -> TypeSlice {
    TypeSlice {
        ty: Box::new(_visitor.fold_type(* _i . ty)),
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
    }
}

pub fn fold_type_trait_object<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeTraitObject) -> TypeTraitObject {
    TypeTraitObject {
        dyn_token: (_i . dyn_token).map(|it| { Token ! [ dyn ](tokens_helper(_visitor, &(it).0)) }),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_type_param_bound(it) }),
    }
}

pub fn fold_type_tuple<V: Folder + ?Sized>(_visitor: &mut V, _i: TypeTuple) -> TypeTuple {
    TypeTuple {
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        tys: FoldHelper::lift(_i . tys, |it| { _visitor.fold_type(it) }),
    }
}

pub fn fold_un_op<V: Folder + ?Sized>(_visitor: &mut V, _i: UnOp) -> UnOp {
    use ::UnOp::*;
    match _i {
        Deref(_binding_0, ) => {
            Deref (
                Token ! [ * ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Not(_binding_0, ) => {
            Not (
                Token ! [ ! ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Neg(_binding_0, ) => {
            Neg (
                Token ! [ - ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}

pub fn fold_unsafety<V: Folder + ?Sized>(_visitor: &mut V, _i: Unsafety) -> Unsafety {
    use ::Unsafety::*;
    match _i {
        Unsafe(_binding_0, ) => {
            Unsafe (
                Token ! [ unsafe ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        Normal => { Normal }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_use_glob<V: Folder + ?Sized>(_visitor: &mut V, _i: UseGlob) -> UseGlob {
    UseGlob {
        star_token: Token ! [ * ](tokens_helper(_visitor, &(_i . star_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_use_list<V: Folder + ?Sized>(_visitor: &mut V, _i: UseList) -> UseList {
    UseList {
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        items: FoldHelper::lift(_i . items, |it| { _visitor.fold_use_tree(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_use_path<V: Folder + ?Sized>(_visitor: &mut V, _i: UsePath) -> UsePath {
    UsePath {
        ident: _visitor.fold_ident(_i . ident),
        rename: (_i . rename).map(|it| { (
            Token ! [ as ](tokens_helper(_visitor, &(( it ) . 0).0)),
            _visitor.fold_ident(( it ) . 1),
        ) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_use_tree<V: Folder + ?Sized>(_visitor: &mut V, _i: UseTree) -> UseTree {
    use ::UseTree::*;
    match _i {
        Path(_binding_0, ) => {
            Path (
                _visitor.fold_use_path(_binding_0),
            )
        }
        Glob(_binding_0, ) => {
            Glob (
                _visitor.fold_use_glob(_binding_0),
            )
        }
        List(_binding_0, ) => {
            List (
                _visitor.fold_use_list(_binding_0),
            )
        }
    }
}

pub fn fold_variant<V: Folder + ?Sized>(_visitor: &mut V, _i: Variant) -> Variant {
    Variant {
        ident: _visitor.fold_ident(_i . ident),
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        data: _visitor.fold_variant_data(_i . data),
        discriminant: (_i . discriminant).map(|it| { _visitor.fold_expr(it) }),
        eq_token: (_i . eq_token).map(|it| { Token ! [ = ](tokens_helper(_visitor, &(it).0)) }),
    }
}

pub fn fold_variant_data<V: Folder + ?Sized>(_visitor: &mut V, _i: VariantData) -> VariantData {
    use ::VariantData::*;
    match _i {
        Struct(_binding_0, _binding_1, ) => {
            Struct (
                FoldHelper::lift(_binding_0, |it| { _visitor.fold_field(it) }),
                Brace(tokens_helper(_visitor, &(_binding_1).0)),
            )
        }
        Tuple(_binding_0, _binding_1, ) => {
            Tuple (
                FoldHelper::lift(_binding_0, |it| { _visitor.fold_field(it) }),
                Paren(tokens_helper(_visitor, &(_binding_1).0)),
            )
        }
        Unit => { Unit }
    }
}

pub fn fold_vis_crate<V: Folder + ?Sized>(_visitor: &mut V, _i: VisCrate) -> VisCrate {
    VisCrate {
        pub_token: Token ! [ pub ](tokens_helper(_visitor, &(_i . pub_token).0)),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        crate_token: Token ! [ crate ](tokens_helper(_visitor, &(_i . crate_token).0)),
    }
}

pub fn fold_vis_inherited<V: Folder + ?Sized>(_visitor: &mut V, _i: VisInherited) -> VisInherited {
    VisInherited {
    }
}

pub fn fold_vis_public<V: Folder + ?Sized>(_visitor: &mut V, _i: VisPublic) -> VisPublic {
    VisPublic {
        pub_token: Token ! [ pub ](tokens_helper(_visitor, &(_i . pub_token).0)),
    }
}

pub fn fold_vis_restricted<V: Folder + ?Sized>(_visitor: &mut V, _i: VisRestricted) -> VisRestricted {
    VisRestricted {
        pub_token: Token ! [ pub ](tokens_helper(_visitor, &(_i . pub_token).0)),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        in_token: (_i . in_token).map(|it| { Token ! [ in ](tokens_helper(_visitor, &(it).0)) }),
        path: Box::new(_visitor.fold_path(* _i . path)),
    }
}

pub fn fold_visibility<V: Folder + ?Sized>(_visitor: &mut V, _i: Visibility) -> Visibility {
    use ::Visibility::*;
    match _i {
        Public(_binding_0, ) => {
            Public (
                _visitor.fold_vis_public(_binding_0),
            )
        }
        Crate(_binding_0, ) => {
            Crate (
                _visitor.fold_vis_crate(_binding_0),
            )
        }
        Restricted(_binding_0, ) => {
            Restricted (
                _visitor.fold_vis_restricted(_binding_0),
            )
        }
        Inherited(_binding_0, ) => {
            Inherited (
                _visitor.fold_vis_inherited(_binding_0),
            )
        }
    }
}

pub fn fold_where_bound_predicate<V: Folder + ?Sized>(_visitor: &mut V, _i: WhereBoundPredicate) -> WhereBoundPredicate {
    WhereBoundPredicate {
        bound_lifetimes: (_i . bound_lifetimes).map(|it| { _visitor.fold_bound_lifetimes(it) }),
        bounded_ty: _visitor.fold_type(_i . bounded_ty),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_type_param_bound(it) }),
    }
}

pub fn fold_where_clause<V: Folder + ?Sized>(_visitor: &mut V, _i: WhereClause) -> WhereClause {
    WhereClause {
        where_token: Token ! [ where ](tokens_helper(_visitor, &(_i . where_token).0)),
        predicates: FoldHelper::lift(_i . predicates, |it| { _visitor.fold_where_predicate(it) }),
    }
}

pub fn fold_where_eq_predicate<V: Folder + ?Sized>(_visitor: &mut V, _i: WhereEqPredicate) -> WhereEqPredicate {
    WhereEqPredicate {
        lhs_ty: _visitor.fold_type(_i . lhs_ty),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        rhs_ty: _visitor.fold_type(_i . rhs_ty),
    }
}

pub fn fold_where_predicate<V: Folder + ?Sized>(_visitor: &mut V, _i: WherePredicate) -> WherePredicate {
    use ::WherePredicate::*;
    match _i {
        BoundPredicate(_binding_0, ) => {
            BoundPredicate (
                _visitor.fold_where_bound_predicate(_binding_0),
            )
        }
        RegionPredicate(_binding_0, ) => {
            RegionPredicate (
                _visitor.fold_where_region_predicate(_binding_0),
            )
        }
        EqPredicate(_binding_0, ) => {
            EqPredicate (
                _visitor.fold_where_eq_predicate(_binding_0),
            )
        }
    }
}

pub fn fold_where_region_predicate<V: Folder + ?Sized>(_visitor: &mut V, _i: WhereRegionPredicate) -> WhereRegionPredicate {
    WhereRegionPredicate {
        lifetime: _visitor.fold_lifetime(_i . lifetime),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_lifetime(it) }),
    }
}

