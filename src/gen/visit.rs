// THIS FILE IS AUTOMATICALLY GENERATED; DO NOT EDIT

//! AST walker. Each overridden visit method has full control over what
//! happens with its node, it can do its own traversal of the node's children,
//! call `visit::walk_*` to apply the default traversal algorithm, or prevent
//! deeper traversal by doing nothing.

#![cfg_attr(rustfmt, rustfmt_skip)]

#![cfg_attr(feature = "cargo-clippy", allow(match_same_arms))]

use *;
use proc_macro2::Span;
use gen::helper::visit::*;


#[cfg(feature = "full")]
macro_rules! full {
    ($e:expr) => { $e }
}

#[cfg(not(feature = "full"))]
macro_rules! full {
    ($e:expr) => { unreachable!() }
}


/// Each method of the Visitor trait is a hook to be potentially
/// overridden.  Each method's default implementation recursively visits
/// the substructure of the input via the corresponding `walk` method;
/// e.g. the `visit_mod` method by default calls `visit::walk_mod`.
///
/// If you want to ensure that your code handles every variant
/// explicitly, you need to override each method.  (And you also need
/// to monitor future changes to `Visitor` in case a new method with a
/// new default implementation gets introduced.)
pub trait Visitor<'ast> {

fn visit_abi(&mut self, i: &'ast Abi) { visit_abi(self, i) }

fn visit_abi_kind(&mut self, i: &'ast AbiKind) { visit_abi_kind(self, i) }

fn visit_angle_bracketed_generic_arguments(&mut self, i: &'ast AngleBracketedGenericArguments) { visit_angle_bracketed_generic_arguments(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_arg_captured(&mut self, i: &'ast ArgCaptured) { visit_arg_captured(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_arg_self(&mut self, i: &'ast ArgSelf) { visit_arg_self(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_arg_self_ref(&mut self, i: &'ast ArgSelfRef) { visit_arg_self_ref(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_arm(&mut self, i: &'ast Arm) { visit_arm(self, i) }

fn visit_attr_style(&mut self, i: &'ast AttrStyle) { visit_attr_style(self, i) }

fn visit_attribute(&mut self, i: &'ast Attribute) { visit_attribute(self, i) }

fn visit_bare_fn_arg(&mut self, i: &'ast BareFnArg) { visit_bare_fn_arg(self, i) }

fn visit_bare_fn_arg_name(&mut self, i: &'ast BareFnArgName) { visit_bare_fn_arg_name(self, i) }

fn visit_bare_fn_type(&mut self, i: &'ast BareFnType) { visit_bare_fn_type(self, i) }

fn visit_bin_op(&mut self, i: &'ast BinOp) { visit_bin_op(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_binding_mode(&mut self, i: &'ast BindingMode) { visit_binding_mode(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_block(&mut self, i: &'ast Block) { visit_block(self, i) }

fn visit_body(&mut self, i: &'ast Body) { visit_body(self, i) }

fn visit_body_enum(&mut self, i: &'ast BodyEnum) { visit_body_enum(self, i) }

fn visit_body_struct(&mut self, i: &'ast BodyStruct) { visit_body_struct(self, i) }

fn visit_bound_lifetimes(&mut self, i: &'ast BoundLifetimes) { visit_bound_lifetimes(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_capture_by(&mut self, i: &'ast CaptureBy) { visit_capture_by(self, i) }

fn visit_const_param(&mut self, i: &'ast ConstParam) { visit_const_param(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_constness(&mut self, i: &'ast Constness) { visit_constness(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_defaultness(&mut self, i: &'ast Defaultness) { visit_defaultness(self, i) }

fn visit_derive_input(&mut self, i: &'ast DeriveInput) { visit_derive_input(self, i) }

fn visit_expr(&mut self, i: &'ast Expr) { visit_expr(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_addr_of(&mut self, i: &'ast ExprAddrOf) { visit_expr_addr_of(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_array(&mut self, i: &'ast ExprArray) { visit_expr_array(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_assign(&mut self, i: &'ast ExprAssign) { visit_expr_assign(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_assign_op(&mut self, i: &'ast ExprAssignOp) { visit_expr_assign_op(self, i) }

fn visit_expr_binary(&mut self, i: &'ast ExprBinary) { visit_expr_binary(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_block(&mut self, i: &'ast ExprBlock) { visit_expr_block(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_box(&mut self, i: &'ast ExprBox) { visit_expr_box(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_break(&mut self, i: &'ast ExprBreak) { visit_expr_break(self, i) }

fn visit_expr_call(&mut self, i: &'ast ExprCall) { visit_expr_call(self, i) }

fn visit_expr_cast(&mut self, i: &'ast ExprCast) { visit_expr_cast(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_catch(&mut self, i: &'ast ExprCatch) { visit_expr_catch(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_closure(&mut self, i: &'ast ExprClosure) { visit_expr_closure(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_continue(&mut self, i: &'ast ExprContinue) { visit_expr_continue(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_field(&mut self, i: &'ast ExprField) { visit_expr_field(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_for_loop(&mut self, i: &'ast ExprForLoop) { visit_expr_for_loop(self, i) }

fn visit_expr_group(&mut self, i: &'ast ExprGroup) { visit_expr_group(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_if(&mut self, i: &'ast ExprIf) { visit_expr_if(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_if_let(&mut self, i: &'ast ExprIfLet) { visit_expr_if_let(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_in_place(&mut self, i: &'ast ExprInPlace) { visit_expr_in_place(self, i) }

fn visit_expr_index(&mut self, i: &'ast ExprIndex) { visit_expr_index(self, i) }

fn visit_expr_kind(&mut self, i: &'ast ExprKind) { visit_expr_kind(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_loop(&mut self, i: &'ast ExprLoop) { visit_expr_loop(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_match(&mut self, i: &'ast ExprMatch) { visit_expr_match(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_method_call(&mut self, i: &'ast ExprMethodCall) { visit_expr_method_call(self, i) }

fn visit_expr_paren(&mut self, i: &'ast ExprParen) { visit_expr_paren(self, i) }

fn visit_expr_path(&mut self, i: &'ast ExprPath) { visit_expr_path(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_range(&mut self, i: &'ast ExprRange) { visit_expr_range(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_repeat(&mut self, i: &'ast ExprRepeat) { visit_expr_repeat(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_ret(&mut self, i: &'ast ExprRet) { visit_expr_ret(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_struct(&mut self, i: &'ast ExprStruct) { visit_expr_struct(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_try(&mut self, i: &'ast ExprTry) { visit_expr_try(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_tuple(&mut self, i: &'ast ExprTuple) { visit_expr_tuple(self, i) }

fn visit_expr_type(&mut self, i: &'ast ExprType) { visit_expr_type(self, i) }

fn visit_expr_unary(&mut self, i: &'ast ExprUnary) { visit_expr_unary(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_unsafe(&mut self, i: &'ast ExprUnsafe) { visit_expr_unsafe(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_while(&mut self, i: &'ast ExprWhile) { visit_expr_while(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_while_let(&mut self, i: &'ast ExprWhileLet) { visit_expr_while_let(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_expr_yield(&mut self, i: &'ast ExprYield) { visit_expr_yield(self, i) }

fn visit_field(&mut self, i: &'ast Field) { visit_field(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_field_pat(&mut self, i: &'ast FieldPat) { visit_field_pat(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_field_value(&mut self, i: &'ast FieldValue) { visit_field_value(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_file(&mut self, i: &'ast File) { visit_file(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_fn_arg(&mut self, i: &'ast FnArg) { visit_fn_arg(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_fn_decl(&mut self, i: &'ast FnDecl) { visit_fn_decl(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_foreign_item(&mut self, i: &'ast ForeignItem) { visit_foreign_item(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_foreign_item_fn(&mut self, i: &'ast ForeignItemFn) { visit_foreign_item_fn(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_foreign_item_static(&mut self, i: &'ast ForeignItemStatic) { visit_foreign_item_static(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_foreign_item_type(&mut self, i: &'ast ForeignItemType) { visit_foreign_item_type(self, i) }

fn visit_generic_argument(&mut self, i: &'ast GenericArgument) { visit_generic_argument(self, i) }

fn visit_generic_param(&mut self, i: &'ast GenericParam) { visit_generic_param(self, i) }

fn visit_generics(&mut self, i: &'ast Generics) { visit_generics(self, i) }

fn visit_ident(&mut self, i: &'ast Ident) { visit_ident(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_impl_item(&mut self, i: &'ast ImplItem) { visit_impl_item(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_impl_item_const(&mut self, i: &'ast ImplItemConst) { visit_impl_item_const(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_impl_item_macro(&mut self, i: &'ast ImplItemMacro) { visit_impl_item_macro(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_impl_item_method(&mut self, i: &'ast ImplItemMethod) { visit_impl_item_method(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_impl_item_type(&mut self, i: &'ast ImplItemType) { visit_impl_item_type(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_impl_polarity(&mut self, i: &'ast ImplPolarity) { visit_impl_polarity(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_in_place_kind(&mut self, i: &'ast InPlaceKind) { visit_in_place_kind(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_index(&mut self, i: &'ast Index) { visit_index(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item(&mut self, i: &'ast Item) { visit_item(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_const(&mut self, i: &'ast ItemConst) { visit_item_const(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_default_impl(&mut self, i: &'ast ItemDefaultImpl) { visit_item_default_impl(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_enum(&mut self, i: &'ast ItemEnum) { visit_item_enum(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_extern_crate(&mut self, i: &'ast ItemExternCrate) { visit_item_extern_crate(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_fn(&mut self, i: &'ast ItemFn) { visit_item_fn(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_foreign_mod(&mut self, i: &'ast ItemForeignMod) { visit_item_foreign_mod(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_impl(&mut self, i: &'ast ItemImpl) { visit_item_impl(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_macro(&mut self, i: &'ast ItemMacro) { visit_item_macro(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_macro2(&mut self, i: &'ast ItemMacro2) { visit_item_macro2(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_mod(&mut self, i: &'ast ItemMod) { visit_item_mod(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_static(&mut self, i: &'ast ItemStatic) { visit_item_static(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_struct(&mut self, i: &'ast ItemStruct) { visit_item_struct(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_trait(&mut self, i: &'ast ItemTrait) { visit_item_trait(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_type(&mut self, i: &'ast ItemType) { visit_item_type(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_union(&mut self, i: &'ast ItemUnion) { visit_item_union(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_item_use(&mut self, i: &'ast ItemUse) { visit_item_use(self, i) }

fn visit_lifetime(&mut self, i: &'ast Lifetime) { visit_lifetime(self, i) }

fn visit_lifetime_def(&mut self, i: &'ast LifetimeDef) { visit_lifetime_def(self, i) }

fn visit_lit(&mut self, i: &'ast Lit) { visit_lit(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_local(&mut self, i: &'ast Local) { visit_local(self, i) }

fn visit_macro(&mut self, i: &'ast Macro) { visit_macro(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_member(&mut self, i: &'ast Member) { visit_member(self, i) }

fn visit_meta_item(&mut self, i: &'ast MetaItem) { visit_meta_item(self, i) }

fn visit_meta_item_list(&mut self, i: &'ast MetaItemList) { visit_meta_item_list(self, i) }

fn visit_meta_name_value(&mut self, i: &'ast MetaNameValue) { visit_meta_name_value(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_method_sig(&mut self, i: &'ast MethodSig) { visit_method_sig(self, i) }

fn visit_mut_type(&mut self, i: &'ast MutType) { visit_mut_type(self, i) }

fn visit_mutability(&mut self, i: &'ast Mutability) { visit_mutability(self, i) }

fn visit_nested_meta_item(&mut self, i: &'ast NestedMetaItem) { visit_nested_meta_item(self, i) }

fn visit_parenthesized_generic_arguments(&mut self, i: &'ast ParenthesizedGenericArguments) { visit_parenthesized_generic_arguments(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat(&mut self, i: &'ast Pat) { visit_pat(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_box(&mut self, i: &'ast PatBox) { visit_pat_box(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_ident(&mut self, i: &'ast PatIdent) { visit_pat_ident(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_lit(&mut self, i: &'ast PatLit) { visit_pat_lit(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_path(&mut self, i: &'ast PatPath) { visit_pat_path(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_range(&mut self, i: &'ast PatRange) { visit_pat_range(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_ref(&mut self, i: &'ast PatRef) { visit_pat_ref(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_slice(&mut self, i: &'ast PatSlice) { visit_pat_slice(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_struct(&mut self, i: &'ast PatStruct) { visit_pat_struct(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_tuple(&mut self, i: &'ast PatTuple) { visit_pat_tuple(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_tuple_struct(&mut self, i: &'ast PatTupleStruct) { visit_pat_tuple_struct(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_pat_wild(&mut self, i: &'ast PatWild) { visit_pat_wild(self, i) }

fn visit_path(&mut self, i: &'ast Path) { visit_path(self, i) }

fn visit_path_arguments(&mut self, i: &'ast PathArguments) { visit_path_arguments(self, i) }

fn visit_path_segment(&mut self, i: &'ast PathSegment) { visit_path_segment(self, i) }

fn visit_poly_trait_ref(&mut self, i: &'ast PolyTraitRef) { visit_poly_trait_ref(self, i) }

fn visit_qself(&mut self, i: &'ast QSelf) { visit_qself(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_range_limits(&mut self, i: &'ast RangeLimits) { visit_range_limits(self, i) }

fn visit_return_type(&mut self, i: &'ast ReturnType) { visit_return_type(self, i) }

fn visit_span(&mut self, i: &'ast Span) { visit_span(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_stmt(&mut self, i: &'ast Stmt) { visit_stmt(self, i) }

fn visit_trait_bound_modifier(&mut self, i: &'ast TraitBoundModifier) { visit_trait_bound_modifier(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_trait_item(&mut self, i: &'ast TraitItem) { visit_trait_item(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_trait_item_const(&mut self, i: &'ast TraitItemConst) { visit_trait_item_const(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_trait_item_macro(&mut self, i: &'ast TraitItemMacro) { visit_trait_item_macro(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_trait_item_method(&mut self, i: &'ast TraitItemMethod) { visit_trait_item_method(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_trait_item_type(&mut self, i: &'ast TraitItemType) { visit_trait_item_type(self, i) }

fn visit_type(&mut self, i: &'ast Type) { visit_type(self, i) }

fn visit_type_array(&mut self, i: &'ast TypeArray) { visit_type_array(self, i) }

fn visit_type_bare_fn(&mut self, i: &'ast TypeBareFn) { visit_type_bare_fn(self, i) }

fn visit_type_binding(&mut self, i: &'ast TypeBinding) { visit_type_binding(self, i) }

fn visit_type_group(&mut self, i: &'ast TypeGroup) { visit_type_group(self, i) }

fn visit_type_impl_trait(&mut self, i: &'ast TypeImplTrait) { visit_type_impl_trait(self, i) }

fn visit_type_infer(&mut self, i: &'ast TypeInfer) { visit_type_infer(self, i) }

fn visit_type_never(&mut self, i: &'ast TypeNever) { visit_type_never(self, i) }

fn visit_type_param(&mut self, i: &'ast TypeParam) { visit_type_param(self, i) }

fn visit_type_param_bound(&mut self, i: &'ast TypeParamBound) { visit_type_param_bound(self, i) }

fn visit_type_paren(&mut self, i: &'ast TypeParen) { visit_type_paren(self, i) }

fn visit_type_path(&mut self, i: &'ast TypePath) { visit_type_path(self, i) }

fn visit_type_ptr(&mut self, i: &'ast TypePtr) { visit_type_ptr(self, i) }

fn visit_type_reference(&mut self, i: &'ast TypeReference) { visit_type_reference(self, i) }

fn visit_type_slice(&mut self, i: &'ast TypeSlice) { visit_type_slice(self, i) }

fn visit_type_trait_object(&mut self, i: &'ast TypeTraitObject) { visit_type_trait_object(self, i) }

fn visit_type_tuple(&mut self, i: &'ast TypeTuple) { visit_type_tuple(self, i) }

fn visit_un_op(&mut self, i: &'ast UnOp) { visit_un_op(self, i) }

fn visit_unsafety(&mut self, i: &'ast Unsafety) { visit_unsafety(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_use_glob(&mut self, i: &'ast UseGlob) { visit_use_glob(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_use_list(&mut self, i: &'ast UseList) { visit_use_list(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_use_path(&mut self, i: &'ast UsePath) { visit_use_path(self, i) }
# [ cfg ( feature = "full" ) ]
fn visit_use_tree(&mut self, i: &'ast UseTree) { visit_use_tree(self, i) }

fn visit_variant(&mut self, i: &'ast Variant) { visit_variant(self, i) }

fn visit_variant_data(&mut self, i: &'ast VariantData) { visit_variant_data(self, i) }

fn visit_vis_crate(&mut self, i: &'ast VisCrate) { visit_vis_crate(self, i) }

fn visit_vis_inherited(&mut self, i: &'ast VisInherited) { visit_vis_inherited(self, i) }

fn visit_vis_public(&mut self, i: &'ast VisPublic) { visit_vis_public(self, i) }

fn visit_vis_restricted(&mut self, i: &'ast VisRestricted) { visit_vis_restricted(self, i) }

fn visit_visibility(&mut self, i: &'ast Visibility) { visit_visibility(self, i) }

fn visit_where_bound_predicate(&mut self, i: &'ast WhereBoundPredicate) { visit_where_bound_predicate(self, i) }

fn visit_where_clause(&mut self, i: &'ast WhereClause) { visit_where_clause(self, i) }

fn visit_where_eq_predicate(&mut self, i: &'ast WhereEqPredicate) { visit_where_eq_predicate(self, i) }

fn visit_where_predicate(&mut self, i: &'ast WherePredicate) { visit_where_predicate(self, i) }

fn visit_where_region_predicate(&mut self, i: &'ast WhereRegionPredicate) { visit_where_region_predicate(self, i) }

}


pub fn visit_abi<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Abi) {
    tokens_helper(_visitor, &(& _i . extern_token).0);
    _visitor.visit_abi_kind(& _i . kind);
}

pub fn visit_abi_kind<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast AbiKind) {
    use ::AbiKind::*;
    match *_i {
        Named(ref _binding_0, ) => {
            _visitor.visit_lit(_binding_0);
        }
        Default => { }
    }
}

pub fn visit_angle_bracketed_generic_arguments<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast AngleBracketedGenericArguments) {
    if let Some(ref it) = _i . turbofish { tokens_helper(_visitor, &(it).0) };
    tokens_helper(_visitor, &(& _i . lt_token).0);
    for el in & _i . args { let it = el.item(); _visitor.visit_generic_argument(it) };
    tokens_helper(_visitor, &(& _i . gt_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_arg_captured<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ArgCaptured) {
    _visitor.visit_pat(& _i . pat);
    tokens_helper(_visitor, &(& _i . colon_token).0);
    _visitor.visit_type(& _i . ty);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_arg_self<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ArgSelf) {
    _visitor.visit_mutability(& _i . mutbl);
    tokens_helper(_visitor, &(& _i . self_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_arg_self_ref<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ArgSelfRef) {
    tokens_helper(_visitor, &(& _i . and_token).0);
    tokens_helper(_visitor, &(& _i . self_token).0);
    if let Some(ref it) = _i . lifetime { _visitor.visit_lifetime(it) };
    _visitor.visit_mutability(& _i . mutbl);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_arm<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Arm) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    for el in & _i . pats { let it = el.item(); _visitor.visit_pat(it) };
    if let Some(ref it) = _i . if_token { tokens_helper(_visitor, &(it).0) };
    if let Some(ref it) = _i . guard { _visitor.visit_expr(& * * it) };
    tokens_helper(_visitor, &(& _i . rocket_token).0);
    _visitor.visit_expr(& * _i . body);
    if let Some(ref it) = _i . comma { tokens_helper(_visitor, &(it).0) };
}

pub fn visit_attr_style<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast AttrStyle) {
    use ::AttrStyle::*;
    match *_i {
        Outer => { }
        Inner(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
    }
}

pub fn visit_attribute<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Attribute) {
    _visitor.visit_attr_style(& _i . style);
    tokens_helper(_visitor, &(& _i . pound_token).0);
    tokens_helper(_visitor, &(& _i . bracket_token).0);
    _visitor.visit_path(& _i . path);
    // Skipped field _i . tts;
    // Skipped field _i . is_sugared_doc;
}

pub fn visit_bare_fn_arg<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast BareFnArg) {
    if let Some(ref it) = _i . name { 
            _visitor.visit_bare_fn_arg_name(& ( it ) . 0);
            tokens_helper(_visitor, &(& ( it ) . 1).0);
         };
    _visitor.visit_type(& _i . ty);
}

pub fn visit_bare_fn_arg_name<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast BareFnArgName) {
    use ::BareFnArgName::*;
    match *_i {
        Named(ref _binding_0, ) => {
            _visitor.visit_ident(_binding_0);
        }
        Wild(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
    }
}

pub fn visit_bare_fn_type<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast BareFnType) {
    if let Some(ref it) = _i . lifetimes { _visitor.visit_bound_lifetimes(it) };
    _visitor.visit_unsafety(& _i . unsafety);
    if let Some(ref it) = _i . abi { _visitor.visit_abi(it) };
    tokens_helper(_visitor, &(& _i . fn_token).0);
    tokens_helper(_visitor, &(& _i . paren_token).0);
    for el in & _i . inputs { let it = el.item(); _visitor.visit_bare_fn_arg(it) };
    if let Some(ref it) = _i . variadic { tokens_helper(_visitor, &(it).0) };
    _visitor.visit_return_type(& _i . output);
}

pub fn visit_bin_op<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast BinOp) {
    use ::BinOp::*;
    match *_i {
        Add(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Sub(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Mul(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Div(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Rem(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        And(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Or(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        BitXor(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        BitAnd(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        BitOr(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Shl(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Shr(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Eq(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Lt(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Le(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Ne(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Ge(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Gt(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        AddEq(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        SubEq(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        MulEq(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        DivEq(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        RemEq(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        BitXorEq(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        BitAndEq(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        BitOrEq(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        ShlEq(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        ShrEq(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_binding_mode<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast BindingMode) {
    use ::BindingMode::*;
    match *_i {
        ByRef(ref _binding_0, ref _binding_1, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
            _visitor.visit_mutability(_binding_1);
        }
        ByValue(ref _binding_0, ) => {
            _visitor.visit_mutability(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_block<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Block) {
    tokens_helper(_visitor, &(& _i . brace_token).0);
    for it in & _i . stmts { _visitor.visit_stmt(it) };
}

pub fn visit_body<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Body) {
    use ::Body::*;
    match *_i {
        Enum(ref _binding_0, ) => {
            _visitor.visit_body_enum(_binding_0);
        }
        Struct(ref _binding_0, ) => {
            _visitor.visit_body_struct(_binding_0);
        }
    }
}

pub fn visit_body_enum<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast BodyEnum) {
    tokens_helper(_visitor, &(& _i . enum_token).0);
    tokens_helper(_visitor, &(& _i . brace_token).0);
    for el in & _i . variants { let it = el.item(); _visitor.visit_variant(it) };
}

pub fn visit_body_struct<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast BodyStruct) {
    _visitor.visit_variant_data(& _i . data);
    tokens_helper(_visitor, &(& _i . struct_token).0);
    if let Some(ref it) = _i . semi_token { tokens_helper(_visitor, &(it).0) };
}

pub fn visit_bound_lifetimes<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast BoundLifetimes) {
    tokens_helper(_visitor, &(& _i . for_token).0);
    tokens_helper(_visitor, &(& _i . lt_token).0);
    for el in & _i . lifetimes { let it = el.item(); _visitor.visit_lifetime_def(it) };
    tokens_helper(_visitor, &(& _i . gt_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_capture_by<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast CaptureBy) {
    use ::CaptureBy::*;
    match *_i {
        Value(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Ref => { }
    }
}

pub fn visit_const_param<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ConstParam) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    tokens_helper(_visitor, &(& _i . const_token).0);
    _visitor.visit_ident(& _i . ident);
    tokens_helper(_visitor, &(& _i . colon_token).0);
    _visitor.visit_type(& _i . ty);
    if let Some(ref it) = _i . eq_token { tokens_helper(_visitor, &(it).0) };
    if let Some(ref it) = _i . default { _visitor.visit_expr(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_constness<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Constness) {
    use ::Constness::*;
    match *_i {
        Const(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        NotConst => { }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_defaultness<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Defaultness) {
    use ::Defaultness::*;
    match *_i {
        Default(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Final => { }
    }
}

pub fn visit_derive_input<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast DeriveInput) {
    _visitor.visit_ident(& _i . ident);
    _visitor.visit_visibility(& _i . vis);
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_generics(& _i . generics);
    _visitor.visit_body(& _i . body);
}

pub fn visit_expr<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Expr) {
    _visitor.visit_expr_kind(& _i . node);
    for it in & _i . attrs { _visitor.visit_attribute(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_addr_of<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprAddrOf) {
    tokens_helper(_visitor, &(& _i . and_token).0);
    _visitor.visit_mutability(& _i . mutbl);
    _visitor.visit_expr(& * _i . expr);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_array<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprArray) {
    for el in & _i . exprs { let it = el.item(); _visitor.visit_expr(it) };
    tokens_helper(_visitor, &(& _i . bracket_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_assign<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprAssign) {
    _visitor.visit_expr(& * _i . left);
    _visitor.visit_expr(& * _i . right);
    tokens_helper(_visitor, &(& _i . eq_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_assign_op<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprAssignOp) {
    _visitor.visit_bin_op(& _i . op);
    _visitor.visit_expr(& * _i . left);
    _visitor.visit_expr(& * _i . right);
}

pub fn visit_expr_binary<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprBinary) {
    _visitor.visit_bin_op(& _i . op);
    _visitor.visit_expr(& * _i . left);
    _visitor.visit_expr(& * _i . right);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_block<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprBlock) {
    _visitor.visit_block(& _i . block);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_box<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprBox) {
    _visitor.visit_expr(& * _i . expr);
    tokens_helper(_visitor, &(& _i . box_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_break<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprBreak) {
    if let Some(ref it) = _i . label { _visitor.visit_lifetime(it) };
    if let Some(ref it) = _i . expr { _visitor.visit_expr(& * * it) };
    tokens_helper(_visitor, &(& _i . break_token).0);
}

pub fn visit_expr_call<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprCall) {
    _visitor.visit_expr(& * _i . func);
    for el in & _i . args { let it = el.item(); _visitor.visit_expr(it) };
    tokens_helper(_visitor, &(& _i . paren_token).0);
}

pub fn visit_expr_cast<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprCast) {
    _visitor.visit_expr(& * _i . expr);
    tokens_helper(_visitor, &(& _i . as_token).0);
    _visitor.visit_type(& * _i . ty);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_catch<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprCatch) {
    tokens_helper(_visitor, &(& _i . do_token).0);
    tokens_helper(_visitor, &(& _i . catch_token).0);
    _visitor.visit_block(& _i . block);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_closure<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprClosure) {
    _visitor.visit_capture_by(& _i . capture);
    tokens_helper(_visitor, &(& _i . or1_token).0);
    for el in & _i . inputs { let it = el.item(); _visitor.visit_fn_arg(it) };
    tokens_helper(_visitor, &(& _i . or2_token).0);
    _visitor.visit_return_type(& _i . output);
    _visitor.visit_expr(& * _i . body);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_continue<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprContinue) {
    if let Some(ref it) = _i . label { _visitor.visit_lifetime(it) };
    tokens_helper(_visitor, &(& _i . continue_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_field<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprField) {
    _visitor.visit_expr(& * _i . base);
    tokens_helper(_visitor, &(& _i . dot_token).0);
    _visitor.visit_member(& _i . member);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_for_loop<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprForLoop) {
    _visitor.visit_pat(& * _i . pat);
    _visitor.visit_expr(& * _i . expr);
    _visitor.visit_block(& _i . body);
    if let Some(ref it) = _i . label { _visitor.visit_lifetime(it) };
    tokens_helper(_visitor, &(& _i . for_token).0);
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
    tokens_helper(_visitor, &(& _i . in_token).0);
}

pub fn visit_expr_group<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprGroup) {
    _visitor.visit_expr(& * _i . expr);
    tokens_helper(_visitor, &(& _i . group_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_if<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprIf) {
    _visitor.visit_expr(& * _i . cond);
    _visitor.visit_block(& _i . if_true);
    if let Some(ref it) = _i . if_false { _visitor.visit_expr(& * * it) };
    tokens_helper(_visitor, &(& _i . if_token).0);
    if let Some(ref it) = _i . else_token { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_if_let<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprIfLet) {
    _visitor.visit_pat(& * _i . pat);
    _visitor.visit_expr(& * _i . expr);
    _visitor.visit_block(& _i . if_true);
    if let Some(ref it) = _i . if_false { _visitor.visit_expr(& * * it) };
    tokens_helper(_visitor, &(& _i . if_token).0);
    tokens_helper(_visitor, &(& _i . let_token).0);
    tokens_helper(_visitor, &(& _i . eq_token).0);
    if let Some(ref it) = _i . else_token { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_in_place<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprInPlace) {
    _visitor.visit_expr(& * _i . place);
    _visitor.visit_in_place_kind(& _i . kind);
    _visitor.visit_expr(& * _i . value);
}

pub fn visit_expr_index<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprIndex) {
    _visitor.visit_expr(& * _i . expr);
    _visitor.visit_expr(& * _i . index);
    tokens_helper(_visitor, &(& _i . bracket_token).0);
}

pub fn visit_expr_kind<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprKind) {
    use ::ExprKind::*;
    match *_i {
        Box(ref _binding_0, ) => {
            full!(_visitor.visit_expr_box(_binding_0));
        }
        InPlace(ref _binding_0, ) => {
            full!(_visitor.visit_expr_in_place(_binding_0));
        }
        Array(ref _binding_0, ) => {
            full!(_visitor.visit_expr_array(_binding_0));
        }
        Call(ref _binding_0, ) => {
            _visitor.visit_expr_call(_binding_0);
        }
        MethodCall(ref _binding_0, ) => {
            full!(_visitor.visit_expr_method_call(_binding_0));
        }
        Tuple(ref _binding_0, ) => {
            full!(_visitor.visit_expr_tuple(_binding_0));
        }
        Binary(ref _binding_0, ) => {
            _visitor.visit_expr_binary(_binding_0);
        }
        Unary(ref _binding_0, ) => {
            _visitor.visit_expr_unary(_binding_0);
        }
        Lit(ref _binding_0, ) => {
            _visitor.visit_lit(_binding_0);
        }
        Cast(ref _binding_0, ) => {
            _visitor.visit_expr_cast(_binding_0);
        }
        Type(ref _binding_0, ) => {
            _visitor.visit_expr_type(_binding_0);
        }
        If(ref _binding_0, ) => {
            full!(_visitor.visit_expr_if(_binding_0));
        }
        IfLet(ref _binding_0, ) => {
            full!(_visitor.visit_expr_if_let(_binding_0));
        }
        While(ref _binding_0, ) => {
            full!(_visitor.visit_expr_while(_binding_0));
        }
        WhileLet(ref _binding_0, ) => {
            full!(_visitor.visit_expr_while_let(_binding_0));
        }
        ForLoop(ref _binding_0, ) => {
            full!(_visitor.visit_expr_for_loop(_binding_0));
        }
        Loop(ref _binding_0, ) => {
            full!(_visitor.visit_expr_loop(_binding_0));
        }
        Match(ref _binding_0, ) => {
            full!(_visitor.visit_expr_match(_binding_0));
        }
        Closure(ref _binding_0, ) => {
            full!(_visitor.visit_expr_closure(_binding_0));
        }
        Unsafe(ref _binding_0, ) => {
            full!(_visitor.visit_expr_unsafe(_binding_0));
        }
        Block(ref _binding_0, ) => {
            full!(_visitor.visit_expr_block(_binding_0));
        }
        Assign(ref _binding_0, ) => {
            full!(_visitor.visit_expr_assign(_binding_0));
        }
        AssignOp(ref _binding_0, ) => {
            full!(_visitor.visit_expr_assign_op(_binding_0));
        }
        Field(ref _binding_0, ) => {
            full!(_visitor.visit_expr_field(_binding_0));
        }
        Index(ref _binding_0, ) => {
            _visitor.visit_expr_index(_binding_0);
        }
        Range(ref _binding_0, ) => {
            full!(_visitor.visit_expr_range(_binding_0));
        }
        Path(ref _binding_0, ) => {
            _visitor.visit_expr_path(_binding_0);
        }
        AddrOf(ref _binding_0, ) => {
            full!(_visitor.visit_expr_addr_of(_binding_0));
        }
        Break(ref _binding_0, ) => {
            full!(_visitor.visit_expr_break(_binding_0));
        }
        Continue(ref _binding_0, ) => {
            full!(_visitor.visit_expr_continue(_binding_0));
        }
        Ret(ref _binding_0, ) => {
            full!(_visitor.visit_expr_ret(_binding_0));
        }
        Macro(ref _binding_0, ) => {
            _visitor.visit_macro(_binding_0);
        }
        Struct(ref _binding_0, ) => {
            full!(_visitor.visit_expr_struct(_binding_0));
        }
        Repeat(ref _binding_0, ) => {
            full!(_visitor.visit_expr_repeat(_binding_0));
        }
        Paren(ref _binding_0, ) => {
            _visitor.visit_expr_paren(_binding_0);
        }
        Group(ref _binding_0, ) => {
            _visitor.visit_expr_group(_binding_0);
        }
        Try(ref _binding_0, ) => {
            full!(_visitor.visit_expr_try(_binding_0));
        }
        Catch(ref _binding_0, ) => {
            full!(_visitor.visit_expr_catch(_binding_0));
        }
        Yield(ref _binding_0, ) => {
            full!(_visitor.visit_expr_yield(_binding_0));
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_loop<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprLoop) {
    _visitor.visit_block(& _i . body);
    if let Some(ref it) = _i . label { _visitor.visit_lifetime(it) };
    tokens_helper(_visitor, &(& _i . loop_token).0);
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_match<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprMatch) {
    tokens_helper(_visitor, &(& _i . match_token).0);
    tokens_helper(_visitor, &(& _i . brace_token).0);
    _visitor.visit_expr(& * _i . expr);
    for it in & _i . arms { _visitor.visit_arm(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_method_call<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprMethodCall) {
    _visitor.visit_expr(& * _i . expr);
    _visitor.visit_ident(& _i . method);
    for el in & _i . typarams { let it = el.item(); _visitor.visit_type(it) };
    for el in & _i . args { let it = el.item(); _visitor.visit_expr(it) };
    tokens_helper(_visitor, &(& _i . paren_token).0);
    tokens_helper(_visitor, &(& _i . dot_token).0);
    if let Some(ref it) = _i . lt_token { tokens_helper(_visitor, &(it).0) };
    if let Some(ref it) = _i . colon2_token { tokens_helper(_visitor, &(it).0) };
    if let Some(ref it) = _i . gt_token { tokens_helper(_visitor, &(it).0) };
}

pub fn visit_expr_paren<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprParen) {
    _visitor.visit_expr(& * _i . expr);
    tokens_helper(_visitor, &(& _i . paren_token).0);
}

pub fn visit_expr_path<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprPath) {
    if let Some(ref it) = _i . qself { _visitor.visit_qself(it) };
    _visitor.visit_path(& _i . path);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_range<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprRange) {
    if let Some(ref it) = _i . from { _visitor.visit_expr(& * * it) };
    if let Some(ref it) = _i . to { _visitor.visit_expr(& * * it) };
    _visitor.visit_range_limits(& _i . limits);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_repeat<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprRepeat) {
    tokens_helper(_visitor, &(& _i . bracket_token).0);
    tokens_helper(_visitor, &(& _i . semi_token).0);
    _visitor.visit_expr(& * _i . expr);
    _visitor.visit_expr(& * _i . amt);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_ret<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprRet) {
    if let Some(ref it) = _i . expr { _visitor.visit_expr(& * * it) };
    tokens_helper(_visitor, &(& _i . return_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_struct<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprStruct) {
    _visitor.visit_path(& _i . path);
    for el in & _i . fields { let it = el.item(); _visitor.visit_field_value(it) };
    if let Some(ref it) = _i . rest { _visitor.visit_expr(& * * it) };
    if let Some(ref it) = _i . dot2_token { tokens_helper(_visitor, &(it).0) };
    tokens_helper(_visitor, &(& _i . brace_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_try<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprTry) {
    _visitor.visit_expr(& * _i . expr);
    tokens_helper(_visitor, &(& _i . question_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_tuple<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprTuple) {
    for el in & _i . args { let it = el.item(); _visitor.visit_expr(it) };
    tokens_helper(_visitor, &(& _i . paren_token).0);
}

pub fn visit_expr_type<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprType) {
    _visitor.visit_expr(& * _i . expr);
    tokens_helper(_visitor, &(& _i . colon_token).0);
    _visitor.visit_type(& * _i . ty);
}

pub fn visit_expr_unary<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprUnary) {
    _visitor.visit_un_op(& _i . op);
    _visitor.visit_expr(& * _i . expr);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_unsafe<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprUnsafe) {
    tokens_helper(_visitor, &(& _i . unsafe_token).0);
    _visitor.visit_block(& _i . block);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_while<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprWhile) {
    _visitor.visit_expr(& * _i . cond);
    _visitor.visit_block(& _i . body);
    if let Some(ref it) = _i . label { _visitor.visit_lifetime(it) };
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
    tokens_helper(_visitor, &(& _i . while_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_while_let<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprWhileLet) {
    _visitor.visit_pat(& * _i . pat);
    _visitor.visit_expr(& * _i . expr);
    _visitor.visit_block(& _i . body);
    if let Some(ref it) = _i . label { _visitor.visit_lifetime(it) };
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
    tokens_helper(_visitor, &(& _i . while_token).0);
    tokens_helper(_visitor, &(& _i . let_token).0);
    tokens_helper(_visitor, &(& _i . eq_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_expr_yield<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ExprYield) {
    tokens_helper(_visitor, &(& _i . yield_token).0);
    if let Some(ref it) = _i . expr { _visitor.visit_expr(& * * it) };
}

pub fn visit_field<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Field) {
    if let Some(ref it) = _i . ident { _visitor.visit_ident(it) };
    _visitor.visit_visibility(& _i . vis);
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_type(& _i . ty);
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_field_pat<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast FieldPat) {
    _visitor.visit_member(& _i . member);
    _visitor.visit_pat(& * _i . pat);
    // Skipped field _i . is_shorthand;
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
    for it in & _i . attrs { _visitor.visit_attribute(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_field_value<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast FieldValue) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_member(& _i . member);
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
    _visitor.visit_expr(& _i . expr);
    // Skipped field _i . is_shorthand;
}
# [ cfg ( feature = "full" ) ]
pub fn visit_file<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast File) {
    // Skipped field _i . shebang;
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    for it in & _i . items { _visitor.visit_item(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_fn_arg<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast FnArg) {
    use ::FnArg::*;
    match *_i {
        SelfRef(ref _binding_0, ) => {
            _visitor.visit_arg_self_ref(_binding_0);
        }
        SelfValue(ref _binding_0, ) => {
            _visitor.visit_arg_self(_binding_0);
        }
        Captured(ref _binding_0, ) => {
            _visitor.visit_arg_captured(_binding_0);
        }
        Inferred(ref _binding_0, ) => {
            _visitor.visit_pat(_binding_0);
        }
        Ignored(ref _binding_0, ) => {
            _visitor.visit_type(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_fn_decl<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast FnDecl) {
    tokens_helper(_visitor, &(& _i . fn_token).0);
    tokens_helper(_visitor, &(& _i . paren_token).0);
    for el in & _i . inputs { let it = el.item(); _visitor.visit_fn_arg(it) };
    _visitor.visit_return_type(& _i . output);
    _visitor.visit_generics(& _i . generics);
    if let Some(ref it) = _i . variadic { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_foreign_item<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ForeignItem) {
    use ::ForeignItem::*;
    match *_i {
        Fn(ref _binding_0, ) => {
            _visitor.visit_foreign_item_fn(_binding_0);
        }
        Static(ref _binding_0, ) => {
            _visitor.visit_foreign_item_static(_binding_0);
        }
        Type(ref _binding_0, ) => {
            _visitor.visit_foreign_item_type(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_foreign_item_fn<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ForeignItemFn) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    _visitor.visit_ident(& _i . ident);
    _visitor.visit_fn_decl(& * _i . decl);
    tokens_helper(_visitor, &(& _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_foreign_item_static<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ForeignItemStatic) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    tokens_helper(_visitor, &(& _i . static_token).0);
    _visitor.visit_mutability(& _i . mutbl);
    _visitor.visit_ident(& _i . ident);
    tokens_helper(_visitor, &(& _i . colon_token).0);
    _visitor.visit_type(& * _i . ty);
    tokens_helper(_visitor, &(& _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_foreign_item_type<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ForeignItemType) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    tokens_helper(_visitor, &(& _i . type_token).0);
    _visitor.visit_ident(& _i . ident);
    tokens_helper(_visitor, &(& _i . semi_token).0);
}

pub fn visit_generic_argument<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast GenericArgument) {
    use ::GenericArgument::*;
    match *_i {
        Lifetime(ref _binding_0, ) => {
            _visitor.visit_lifetime(_binding_0);
        }
        Type(ref _binding_0, ) => {
            _visitor.visit_type(_binding_0);
        }
        TypeBinding(ref _binding_0, ) => {
            _visitor.visit_type_binding(_binding_0);
        }
        Const(ref _binding_0, ) => {
            _visitor.visit_expr(_binding_0);
        }
    }
}

pub fn visit_generic_param<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast GenericParam) {
    use ::GenericParam::*;
    match *_i {
        Lifetime(ref _binding_0, ) => {
            _visitor.visit_lifetime_def(_binding_0);
        }
        Type(ref _binding_0, ) => {
            _visitor.visit_type_param(_binding_0);
        }
        Const(ref _binding_0, ) => {
            _visitor.visit_const_param(_binding_0);
        }
    }
}

pub fn visit_generics<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Generics) {
    if let Some(ref it) = _i . lt_token { tokens_helper(_visitor, &(it).0) };
    for el in & _i . params { let it = el.item(); _visitor.visit_generic_param(it) };
    if let Some(ref it) = _i . gt_token { tokens_helper(_visitor, &(it).0) };
    if let Some(ref it) = _i . where_clause { _visitor.visit_where_clause(it) };
}

pub fn visit_ident<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Ident) {
    // Skipped field _i . sym;
    _visitor.visit_span(& _i . span);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_impl_item<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ImplItem) {
    use ::ImplItem::*;
    match *_i {
        Const(ref _binding_0, ) => {
            _visitor.visit_impl_item_const(_binding_0);
        }
        Method(ref _binding_0, ) => {
            _visitor.visit_impl_item_method(_binding_0);
        }
        Type(ref _binding_0, ) => {
            _visitor.visit_impl_item_type(_binding_0);
        }
        Macro(ref _binding_0, ) => {
            _visitor.visit_impl_item_macro(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_impl_item_const<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ImplItemConst) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    _visitor.visit_defaultness(& _i . defaultness);
    tokens_helper(_visitor, &(& _i . const_token).0);
    _visitor.visit_ident(& _i . ident);
    tokens_helper(_visitor, &(& _i . colon_token).0);
    _visitor.visit_type(& _i . ty);
    tokens_helper(_visitor, &(& _i . eq_token).0);
    _visitor.visit_expr(& _i . expr);
    tokens_helper(_visitor, &(& _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_impl_item_macro<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ImplItemMacro) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_macro(& _i . mac);
    if let Some(ref it) = _i . semi_token { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_impl_item_method<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ImplItemMethod) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    _visitor.visit_defaultness(& _i . defaultness);
    _visitor.visit_method_sig(& _i . sig);
    _visitor.visit_block(& _i . block);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_impl_item_type<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ImplItemType) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    _visitor.visit_defaultness(& _i . defaultness);
    tokens_helper(_visitor, &(& _i . type_token).0);
    _visitor.visit_ident(& _i . ident);
    _visitor.visit_generics(& _i . generics);
    tokens_helper(_visitor, &(& _i . eq_token).0);
    _visitor.visit_type(& _i . ty);
    tokens_helper(_visitor, &(& _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_impl_polarity<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ImplPolarity) {
    use ::ImplPolarity::*;
    match *_i {
        Positive => { }
        Negative(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_in_place_kind<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast InPlaceKind) {
    use ::InPlaceKind::*;
    match *_i {
        Arrow(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        In(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_index<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Index) {
    // Skipped field _i . index;
    _visitor.visit_span(& _i . span);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Item) {
    use ::Item::*;
    match *_i {
        ExternCrate(ref _binding_0, ) => {
            _visitor.visit_item_extern_crate(_binding_0);
        }
        Use(ref _binding_0, ) => {
            _visitor.visit_item_use(_binding_0);
        }
        Static(ref _binding_0, ) => {
            _visitor.visit_item_static(_binding_0);
        }
        Const(ref _binding_0, ) => {
            _visitor.visit_item_const(_binding_0);
        }
        Fn(ref _binding_0, ) => {
            _visitor.visit_item_fn(_binding_0);
        }
        Mod(ref _binding_0, ) => {
            _visitor.visit_item_mod(_binding_0);
        }
        ForeignMod(ref _binding_0, ) => {
            _visitor.visit_item_foreign_mod(_binding_0);
        }
        Type(ref _binding_0, ) => {
            _visitor.visit_item_type(_binding_0);
        }
        Enum(ref _binding_0, ) => {
            _visitor.visit_item_enum(_binding_0);
        }
        Struct(ref _binding_0, ) => {
            _visitor.visit_item_struct(_binding_0);
        }
        Union(ref _binding_0, ) => {
            _visitor.visit_item_union(_binding_0);
        }
        Trait(ref _binding_0, ) => {
            _visitor.visit_item_trait(_binding_0);
        }
        DefaultImpl(ref _binding_0, ) => {
            _visitor.visit_item_default_impl(_binding_0);
        }
        Impl(ref _binding_0, ) => {
            _visitor.visit_item_impl(_binding_0);
        }
        Macro(ref _binding_0, ) => {
            _visitor.visit_item_macro(_binding_0);
        }
        Macro2(ref _binding_0, ) => {
            _visitor.visit_item_macro2(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_const<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemConst) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    tokens_helper(_visitor, &(& _i . const_token).0);
    _visitor.visit_ident(& _i . ident);
    tokens_helper(_visitor, &(& _i . colon_token).0);
    _visitor.visit_type(& * _i . ty);
    tokens_helper(_visitor, &(& _i . eq_token).0);
    _visitor.visit_expr(& * _i . expr);
    tokens_helper(_visitor, &(& _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_default_impl<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemDefaultImpl) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_unsafety(& _i . unsafety);
    tokens_helper(_visitor, &(& _i . impl_token).0);
    _visitor.visit_path(& _i . path);
    tokens_helper(_visitor, &(& _i . for_token).0);
    tokens_helper(_visitor, &(& _i . dot2_token).0);
    tokens_helper(_visitor, &(& _i . brace_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_enum<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemEnum) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    tokens_helper(_visitor, &(& _i . enum_token).0);
    _visitor.visit_ident(& _i . ident);
    _visitor.visit_generics(& _i . generics);
    tokens_helper(_visitor, &(& _i . brace_token).0);
    for el in & _i . variants { let it = el.item(); _visitor.visit_variant(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_extern_crate<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemExternCrate) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    tokens_helper(_visitor, &(& _i . extern_token).0);
    tokens_helper(_visitor, &(& _i . crate_token).0);
    _visitor.visit_ident(& _i . ident);
    if let Some(ref it) = _i . rename { 
            tokens_helper(_visitor, &(& ( it ) . 0).0);
            _visitor.visit_ident(& ( it ) . 1);
         };
    tokens_helper(_visitor, &(& _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_fn<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemFn) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    _visitor.visit_constness(& _i . constness);
    _visitor.visit_unsafety(& _i . unsafety);
    if let Some(ref it) = _i . abi { _visitor.visit_abi(it) };
    _visitor.visit_fn_decl(& * _i . decl);
    _visitor.visit_ident(& _i . ident);
    _visitor.visit_block(& * _i . block);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_foreign_mod<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemForeignMod) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_abi(& _i . abi);
    tokens_helper(_visitor, &(& _i . brace_token).0);
    for it in & _i . items { _visitor.visit_foreign_item(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_impl<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemImpl) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_defaultness(& _i . defaultness);
    _visitor.visit_unsafety(& _i . unsafety);
    tokens_helper(_visitor, &(& _i . impl_token).0);
    _visitor.visit_generics(& _i . generics);
    if let Some(ref it) = _i . trait_ { 
            _visitor.visit_impl_polarity(& ( it ) . 0);
            _visitor.visit_path(& ( it ) . 1);
            tokens_helper(_visitor, &(& ( it ) . 2).0);
         };
    _visitor.visit_type(& * _i . self_ty);
    tokens_helper(_visitor, &(& _i . brace_token).0);
    for it in & _i . items { _visitor.visit_impl_item(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_macro<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemMacro) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    if let Some(ref it) = _i . ident { _visitor.visit_ident(it) };
    _visitor.visit_macro(& _i . mac);
    if let Some(ref it) = _i . semi_token { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_macro2<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemMacro2) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    tokens_helper(_visitor, &(& _i . macro_token).0);
    _visitor.visit_ident(& _i . ident);
    // Skipped field _i . args;
    // Skipped field _i . body;
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_mod<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemMod) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    tokens_helper(_visitor, &(& _i . mod_token).0);
    _visitor.visit_ident(& _i . ident);
    if let Some(ref it) = _i . content { 
            tokens_helper(_visitor, &(& ( it ) . 0).0);
            for it in & ( it ) . 1 { _visitor.visit_item(it) };
         };
    if let Some(ref it) = _i . semi { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_static<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemStatic) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    tokens_helper(_visitor, &(& _i . static_token).0);
    _visitor.visit_mutability(& _i . mutbl);
    _visitor.visit_ident(& _i . ident);
    tokens_helper(_visitor, &(& _i . colon_token).0);
    _visitor.visit_type(& * _i . ty);
    tokens_helper(_visitor, &(& _i . eq_token).0);
    _visitor.visit_expr(& * _i . expr);
    tokens_helper(_visitor, &(& _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_struct<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemStruct) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    tokens_helper(_visitor, &(& _i . struct_token).0);
    _visitor.visit_ident(& _i . ident);
    _visitor.visit_generics(& _i . generics);
    _visitor.visit_variant_data(& _i . data);
    if let Some(ref it) = _i . semi_token { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_trait<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemTrait) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    _visitor.visit_unsafety(& _i . unsafety);
    if let Some(ref it) = _i . auto_token { tokens_helper(_visitor, &(it).0) };
    tokens_helper(_visitor, &(& _i . trait_token).0);
    _visitor.visit_ident(& _i . ident);
    _visitor.visit_generics(& _i . generics);
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
    for el in & _i . supertraits { let it = el.item(); _visitor.visit_type_param_bound(it) };
    tokens_helper(_visitor, &(& _i . brace_token).0);
    for it in & _i . items { _visitor.visit_trait_item(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_type<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemType) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    tokens_helper(_visitor, &(& _i . type_token).0);
    _visitor.visit_ident(& _i . ident);
    _visitor.visit_generics(& _i . generics);
    tokens_helper(_visitor, &(& _i . eq_token).0);
    _visitor.visit_type(& * _i . ty);
    tokens_helper(_visitor, &(& _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_union<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemUnion) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    tokens_helper(_visitor, &(& _i . union_token).0);
    _visitor.visit_ident(& _i . ident);
    _visitor.visit_generics(& _i . generics);
    _visitor.visit_variant_data(& _i . data);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_item_use<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ItemUse) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_visibility(& _i . vis);
    tokens_helper(_visitor, &(& _i . use_token).0);
    if let Some(ref it) = _i . leading_colon { tokens_helper(_visitor, &(it).0) };
    for el in & _i . prefix { let it = el.item(); _visitor.visit_ident(it) };
    _visitor.visit_use_tree(& _i . tree);
    tokens_helper(_visitor, &(& _i . semi_token).0);
}

pub fn visit_lifetime<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Lifetime) {
    // Skipped field _i . sym;
    _visitor.visit_span(& _i . span);
}

pub fn visit_lifetime_def<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast LifetimeDef) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_lifetime(& _i . lifetime);
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
    for el in & _i . bounds { let it = el.item(); _visitor.visit_lifetime(it) };
}

pub fn visit_lit<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Lit) {
    // Skipped field _i . value;
    _visitor.visit_span(& _i . span);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_local<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Local) {
    tokens_helper(_visitor, &(& _i . let_token).0);
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
    if let Some(ref it) = _i . eq_token { tokens_helper(_visitor, &(it).0) };
    tokens_helper(_visitor, &(& _i . semi_token).0);
    _visitor.visit_pat(& * _i . pat);
    if let Some(ref it) = _i . ty { _visitor.visit_type(& * * it) };
    if let Some(ref it) = _i . init { _visitor.visit_expr(& * * it) };
    for it in & _i . attrs { _visitor.visit_attribute(it) };
}

pub fn visit_macro<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Macro) {
    _visitor.visit_path(& _i . path);
    tokens_helper(_visitor, &(& _i . bang_token).0);
    // Skipped field _i . tokens;
}
# [ cfg ( feature = "full" ) ]
pub fn visit_member<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Member) {
    use ::Member::*;
    match *_i {
        Named(ref _binding_0, ) => {
            _visitor.visit_ident(_binding_0);
        }
        Unnamed(ref _binding_0, ) => {
            _visitor.visit_index(_binding_0);
        }
    }
}

pub fn visit_meta_item<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast MetaItem) {
    use ::MetaItem::*;
    match *_i {
        Term(ref _binding_0, ) => {
            _visitor.visit_ident(_binding_0);
        }
        List(ref _binding_0, ) => {
            _visitor.visit_meta_item_list(_binding_0);
        }
        NameValue(ref _binding_0, ) => {
            _visitor.visit_meta_name_value(_binding_0);
        }
    }
}

pub fn visit_meta_item_list<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast MetaItemList) {
    _visitor.visit_ident(& _i . ident);
    tokens_helper(_visitor, &(& _i . paren_token).0);
    for el in & _i . nested { let it = el.item(); _visitor.visit_nested_meta_item(it) };
}

pub fn visit_meta_name_value<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast MetaNameValue) {
    _visitor.visit_ident(& _i . ident);
    tokens_helper(_visitor, &(& _i . eq_token).0);
    _visitor.visit_lit(& _i . lit);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_method_sig<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast MethodSig) {
    _visitor.visit_constness(& _i . constness);
    _visitor.visit_unsafety(& _i . unsafety);
    if let Some(ref it) = _i . abi { _visitor.visit_abi(it) };
    _visitor.visit_ident(& _i . ident);
    _visitor.visit_fn_decl(& _i . decl);
}

pub fn visit_mut_type<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast MutType) {
    _visitor.visit_type(& _i . ty);
    _visitor.visit_mutability(& _i . mutability);
}

pub fn visit_mutability<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Mutability) {
    use ::Mutability::*;
    match *_i {
        Mutable(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Immutable => { }
    }
}

pub fn visit_nested_meta_item<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast NestedMetaItem) {
    use ::NestedMetaItem::*;
    match *_i {
        MetaItem(ref _binding_0, ) => {
            _visitor.visit_meta_item(_binding_0);
        }
        Literal(ref _binding_0, ) => {
            _visitor.visit_lit(_binding_0);
        }
    }
}

pub fn visit_parenthesized_generic_arguments<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ParenthesizedGenericArguments) {
    tokens_helper(_visitor, &(& _i . paren_token).0);
    for el in & _i . inputs { let it = el.item(); _visitor.visit_type(it) };
    _visitor.visit_return_type(& _i . output);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Pat) {
    use ::Pat::*;
    match *_i {
        Wild(ref _binding_0, ) => {
            _visitor.visit_pat_wild(_binding_0);
        }
        Ident(ref _binding_0, ) => {
            _visitor.visit_pat_ident(_binding_0);
        }
        Struct(ref _binding_0, ) => {
            _visitor.visit_pat_struct(_binding_0);
        }
        TupleStruct(ref _binding_0, ) => {
            _visitor.visit_pat_tuple_struct(_binding_0);
        }
        Path(ref _binding_0, ) => {
            _visitor.visit_pat_path(_binding_0);
        }
        Tuple(ref _binding_0, ) => {
            _visitor.visit_pat_tuple(_binding_0);
        }
        Box(ref _binding_0, ) => {
            _visitor.visit_pat_box(_binding_0);
        }
        Ref(ref _binding_0, ) => {
            _visitor.visit_pat_ref(_binding_0);
        }
        Lit(ref _binding_0, ) => {
            _visitor.visit_pat_lit(_binding_0);
        }
        Range(ref _binding_0, ) => {
            _visitor.visit_pat_range(_binding_0);
        }
        Slice(ref _binding_0, ) => {
            _visitor.visit_pat_slice(_binding_0);
        }
        Macro(ref _binding_0, ) => {
            _visitor.visit_macro(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_box<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatBox) {
    _visitor.visit_pat(& * _i . pat);
    tokens_helper(_visitor, &(& _i . box_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_ident<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatIdent) {
    _visitor.visit_binding_mode(& _i . mode);
    _visitor.visit_ident(& _i . ident);
    if let Some(ref it) = _i . subpat { _visitor.visit_pat(& * * it) };
    if let Some(ref it) = _i . at_token { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_lit<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatLit) {
    _visitor.visit_expr(& * _i . expr);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_path<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatPath) {
    if let Some(ref it) = _i . qself { _visitor.visit_qself(it) };
    _visitor.visit_path(& _i . path);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_range<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatRange) {
    _visitor.visit_expr(& * _i . lo);
    _visitor.visit_expr(& * _i . hi);
    _visitor.visit_range_limits(& _i . limits);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_ref<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatRef) {
    _visitor.visit_pat(& * _i . pat);
    _visitor.visit_mutability(& _i . mutbl);
    tokens_helper(_visitor, &(& _i . and_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_slice<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatSlice) {
    for el in & _i . front { let it = el.item(); _visitor.visit_pat(it) };
    if let Some(ref it) = _i . middle { _visitor.visit_pat(& * * it) };
    for el in & _i . back { let it = el.item(); _visitor.visit_pat(it) };
    if let Some(ref it) = _i . dot2_token { tokens_helper(_visitor, &(it).0) };
    if let Some(ref it) = _i . comma_token { tokens_helper(_visitor, &(it).0) };
    tokens_helper(_visitor, &(& _i . bracket_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_struct<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatStruct) {
    _visitor.visit_path(& _i . path);
    for el in & _i . fields { let it = el.item(); _visitor.visit_field_pat(it) };
    tokens_helper(_visitor, &(& _i . brace_token).0);
    if let Some(ref it) = _i . dot2_token { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_tuple<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatTuple) {
    for el in & _i . pats { let it = el.item(); _visitor.visit_pat(it) };
    // Skipped field _i . dots_pos;
    tokens_helper(_visitor, &(& _i . paren_token).0);
    if let Some(ref it) = _i . dot2_token { tokens_helper(_visitor, &(it).0) };
    if let Some(ref it) = _i . comma_token { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_tuple_struct<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatTupleStruct) {
    _visitor.visit_path(& _i . path);
    _visitor.visit_pat_tuple(& _i . pat);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_pat_wild<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PatWild) {
    tokens_helper(_visitor, &(& _i . underscore_token).0);
}

pub fn visit_path<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Path) {
    if let Some(ref it) = _i . leading_colon { tokens_helper(_visitor, &(it).0) };
    for el in & _i . segments { let it = el.item(); _visitor.visit_path_segment(it) };
}

pub fn visit_path_arguments<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PathArguments) {
    use ::PathArguments::*;
    match *_i {
        None => { }
        AngleBracketed(ref _binding_0, ) => {
            _visitor.visit_angle_bracketed_generic_arguments(_binding_0);
        }
        Parenthesized(ref _binding_0, ) => {
            _visitor.visit_parenthesized_generic_arguments(_binding_0);
        }
    }
}

pub fn visit_path_segment<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PathSegment) {
    _visitor.visit_ident(& _i . ident);
    _visitor.visit_path_arguments(& _i . arguments);
}

pub fn visit_poly_trait_ref<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast PolyTraitRef) {
    if let Some(ref it) = _i . bound_lifetimes { _visitor.visit_bound_lifetimes(it) };
    _visitor.visit_path(& _i . trait_ref);
}

pub fn visit_qself<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast QSelf) {
    tokens_helper(_visitor, &(& _i . lt_token).0);
    _visitor.visit_type(& * _i . ty);
    // Skipped field _i . position;
    if let Some(ref it) = _i . as_token { tokens_helper(_visitor, &(it).0) };
    tokens_helper(_visitor, &(& _i . gt_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_range_limits<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast RangeLimits) {
    use ::RangeLimits::*;
    match *_i {
        HalfOpen(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Closed(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
    }
}

pub fn visit_return_type<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast ReturnType) {
    use ::ReturnType::*;
    match *_i {
        Default => { }
        Type(ref _binding_0, ref _binding_1, ) => {
            _visitor.visit_type(& * * _binding_0);
            tokens_helper(_visitor, &(_binding_1).0);
        }
    }
}

pub fn visit_span<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Span) {
}
# [ cfg ( feature = "full" ) ]
pub fn visit_stmt<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Stmt) {
    use ::Stmt::*;
    match *_i {
        Local(ref _binding_0, ) => {
            _visitor.visit_local(& * * _binding_0);
        }
        Item(ref _binding_0, ) => {
            _visitor.visit_item(& * * _binding_0);
        }
        Expr(ref _binding_0, ) => {
            _visitor.visit_expr(& * * _binding_0);
        }
        Semi(ref _binding_0, ref _binding_1, ) => {
            _visitor.visit_expr(& * * _binding_0);
            tokens_helper(_visitor, &(_binding_1).0);
        }
    }
}

pub fn visit_trait_bound_modifier<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TraitBoundModifier) {
    use ::TraitBoundModifier::*;
    match *_i {
        None => { }
        Maybe(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_trait_item<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TraitItem) {
    use ::TraitItem::*;
    match *_i {
        Const(ref _binding_0, ) => {
            _visitor.visit_trait_item_const(_binding_0);
        }
        Method(ref _binding_0, ) => {
            _visitor.visit_trait_item_method(_binding_0);
        }
        Type(ref _binding_0, ) => {
            _visitor.visit_trait_item_type(_binding_0);
        }
        Macro(ref _binding_0, ) => {
            _visitor.visit_trait_item_macro(_binding_0);
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_trait_item_const<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TraitItemConst) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    tokens_helper(_visitor, &(& _i . const_token).0);
    _visitor.visit_ident(& _i . ident);
    tokens_helper(_visitor, &(& _i . colon_token).0);
    _visitor.visit_type(& _i . ty);
    if let Some(ref it) = _i . default { 
            tokens_helper(_visitor, &(& ( it ) . 0).0);
            _visitor.visit_expr(& ( it ) . 1);
         };
    tokens_helper(_visitor, &(& _i . semi_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_trait_item_macro<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TraitItemMacro) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_macro(& _i . mac);
    if let Some(ref it) = _i . semi_token { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_trait_item_method<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TraitItemMethod) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_method_sig(& _i . sig);
    if let Some(ref it) = _i . default { _visitor.visit_block(it) };
    if let Some(ref it) = _i . semi_token { tokens_helper(_visitor, &(it).0) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_trait_item_type<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TraitItemType) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    tokens_helper(_visitor, &(& _i . type_token).0);
    _visitor.visit_ident(& _i . ident);
    _visitor.visit_generics(& _i . generics);
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
    for el in & _i . bounds { let it = el.item(); _visitor.visit_type_param_bound(it) };
    if let Some(ref it) = _i . default { 
            tokens_helper(_visitor, &(& ( it ) . 0).0);
            _visitor.visit_type(& ( it ) . 1);
         };
    tokens_helper(_visitor, &(& _i . semi_token).0);
}

pub fn visit_type<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Type) {
    use ::Type::*;
    match *_i {
        Slice(ref _binding_0, ) => {
            _visitor.visit_type_slice(_binding_0);
        }
        Array(ref _binding_0, ) => {
            _visitor.visit_type_array(_binding_0);
        }
        Ptr(ref _binding_0, ) => {
            _visitor.visit_type_ptr(_binding_0);
        }
        Reference(ref _binding_0, ) => {
            _visitor.visit_type_reference(_binding_0);
        }
        BareFn(ref _binding_0, ) => {
            _visitor.visit_type_bare_fn(_binding_0);
        }
        Never(ref _binding_0, ) => {
            _visitor.visit_type_never(_binding_0);
        }
        Tuple(ref _binding_0, ) => {
            _visitor.visit_type_tuple(_binding_0);
        }
        Path(ref _binding_0, ) => {
            _visitor.visit_type_path(_binding_0);
        }
        TraitObject(ref _binding_0, ) => {
            _visitor.visit_type_trait_object(_binding_0);
        }
        ImplTrait(ref _binding_0, ) => {
            _visitor.visit_type_impl_trait(_binding_0);
        }
        Paren(ref _binding_0, ) => {
            _visitor.visit_type_paren(_binding_0);
        }
        Group(ref _binding_0, ) => {
            _visitor.visit_type_group(_binding_0);
        }
        Infer(ref _binding_0, ) => {
            _visitor.visit_type_infer(_binding_0);
        }
        Macro(ref _binding_0, ) => {
            _visitor.visit_macro(_binding_0);
        }
    }
}

pub fn visit_type_array<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeArray) {
    tokens_helper(_visitor, &(& _i . bracket_token).0);
    _visitor.visit_type(& * _i . ty);
    tokens_helper(_visitor, &(& _i . semi_token).0);
    _visitor.visit_expr(& _i . amt);
}

pub fn visit_type_bare_fn<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeBareFn) {
    _visitor.visit_bare_fn_type(& * _i . ty);
}

pub fn visit_type_binding<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeBinding) {
    _visitor.visit_ident(& _i . ident);
    tokens_helper(_visitor, &(& _i . eq_token).0);
    _visitor.visit_type(& _i . ty);
}

pub fn visit_type_group<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeGroup) {
    tokens_helper(_visitor, &(& _i . group_token).0);
    _visitor.visit_type(& * _i . ty);
}

pub fn visit_type_impl_trait<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeImplTrait) {
    tokens_helper(_visitor, &(& _i . impl_token).0);
    for el in & _i . bounds { let it = el.item(); _visitor.visit_type_param_bound(it) };
}

pub fn visit_type_infer<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeInfer) {
    tokens_helper(_visitor, &(& _i . underscore_token).0);
}

pub fn visit_type_never<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeNever) {
    tokens_helper(_visitor, &(& _i . bang_token).0);
}

pub fn visit_type_param<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeParam) {
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_ident(& _i . ident);
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
    for el in & _i . bounds { let it = el.item(); _visitor.visit_type_param_bound(it) };
    if let Some(ref it) = _i . eq_token { tokens_helper(_visitor, &(it).0) };
    if let Some(ref it) = _i . default { _visitor.visit_type(it) };
}

pub fn visit_type_param_bound<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeParamBound) {
    use ::TypeParamBound::*;
    match *_i {
        Trait(ref _binding_0, ref _binding_1, ) => {
            _visitor.visit_poly_trait_ref(_binding_0);
            _visitor.visit_trait_bound_modifier(_binding_1);
        }
        Region(ref _binding_0, ) => {
            _visitor.visit_lifetime(_binding_0);
        }
    }
}

pub fn visit_type_paren<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeParen) {
    tokens_helper(_visitor, &(& _i . paren_token).0);
    _visitor.visit_type(& * _i . ty);
}

pub fn visit_type_path<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypePath) {
    if let Some(ref it) = _i . qself { _visitor.visit_qself(it) };
    _visitor.visit_path(& _i . path);
}

pub fn visit_type_ptr<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypePtr) {
    tokens_helper(_visitor, &(& _i . star_token).0);
    if let Some(ref it) = _i . const_token { tokens_helper(_visitor, &(it).0) };
    _visitor.visit_mut_type(& * _i . ty);
}

pub fn visit_type_reference<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeReference) {
    tokens_helper(_visitor, &(& _i . and_token).0);
    if let Some(ref it) = _i . lifetime { _visitor.visit_lifetime(it) };
    _visitor.visit_mut_type(& * _i . ty);
}

pub fn visit_type_slice<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeSlice) {
    _visitor.visit_type(& * _i . ty);
    tokens_helper(_visitor, &(& _i . bracket_token).0);
}

pub fn visit_type_trait_object<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeTraitObject) {
    if let Some(ref it) = _i . dyn_token { tokens_helper(_visitor, &(it).0) };
    for el in & _i . bounds { let it = el.item(); _visitor.visit_type_param_bound(it) };
}

pub fn visit_type_tuple<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast TypeTuple) {
    tokens_helper(_visitor, &(& _i . paren_token).0);
    for el in & _i . tys { let it = el.item(); _visitor.visit_type(it) };
}

pub fn visit_un_op<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast UnOp) {
    use ::UnOp::*;
    match *_i {
        Deref(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Not(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Neg(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
    }
}

pub fn visit_unsafety<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Unsafety) {
    use ::Unsafety::*;
    match *_i {
        Unsafe(ref _binding_0, ) => {
            tokens_helper(_visitor, &(_binding_0).0);
        }
        Normal => { }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn visit_use_glob<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast UseGlob) {
    tokens_helper(_visitor, &(& _i . star_token).0);
}
# [ cfg ( feature = "full" ) ]
pub fn visit_use_list<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast UseList) {
    tokens_helper(_visitor, &(& _i . brace_token).0);
    for el in & _i . items { let it = el.item(); _visitor.visit_use_tree(it) };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_use_path<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast UsePath) {
    _visitor.visit_ident(& _i . ident);
    if let Some(ref it) = _i . rename { 
            tokens_helper(_visitor, &(& ( it ) . 0).0);
            _visitor.visit_ident(& ( it ) . 1);
         };
}
# [ cfg ( feature = "full" ) ]
pub fn visit_use_tree<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast UseTree) {
    use ::UseTree::*;
    match *_i {
        Path(ref _binding_0, ) => {
            _visitor.visit_use_path(_binding_0);
        }
        Glob(ref _binding_0, ) => {
            _visitor.visit_use_glob(_binding_0);
        }
        List(ref _binding_0, ) => {
            _visitor.visit_use_list(_binding_0);
        }
    }
}

pub fn visit_variant<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Variant) {
    _visitor.visit_ident(& _i . ident);
    for it in & _i . attrs { _visitor.visit_attribute(it) };
    _visitor.visit_variant_data(& _i . data);
    if let Some(ref it) = _i . discriminant { _visitor.visit_expr(it) };
    if let Some(ref it) = _i . eq_token { tokens_helper(_visitor, &(it).0) };
}

pub fn visit_variant_data<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast VariantData) {
    use ::VariantData::*;
    match *_i {
        Struct(ref _binding_0, ref _binding_1, ) => {
            for el in _binding_0 { let it = el.item(); _visitor.visit_field(it) };
            tokens_helper(_visitor, &(_binding_1).0);
        }
        Tuple(ref _binding_0, ref _binding_1, ) => {
            for el in _binding_0 { let it = el.item(); _visitor.visit_field(it) };
            tokens_helper(_visitor, &(_binding_1).0);
        }
        Unit => { }
    }
}

pub fn visit_vis_crate<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast VisCrate) {
    tokens_helper(_visitor, &(& _i . pub_token).0);
    tokens_helper(_visitor, &(& _i . paren_token).0);
    tokens_helper(_visitor, &(& _i . crate_token).0);
}

pub fn visit_vis_inherited<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast VisInherited) {
}

pub fn visit_vis_public<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast VisPublic) {
    tokens_helper(_visitor, &(& _i . pub_token).0);
}

pub fn visit_vis_restricted<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast VisRestricted) {
    tokens_helper(_visitor, &(& _i . pub_token).0);
    tokens_helper(_visitor, &(& _i . paren_token).0);
    if let Some(ref it) = _i . in_token { tokens_helper(_visitor, &(it).0) };
    _visitor.visit_path(& * _i . path);
}

pub fn visit_visibility<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast Visibility) {
    use ::Visibility::*;
    match *_i {
        Public(ref _binding_0, ) => {
            _visitor.visit_vis_public(_binding_0);
        }
        Crate(ref _binding_0, ) => {
            _visitor.visit_vis_crate(_binding_0);
        }
        Restricted(ref _binding_0, ) => {
            _visitor.visit_vis_restricted(_binding_0);
        }
        Inherited(ref _binding_0, ) => {
            _visitor.visit_vis_inherited(_binding_0);
        }
    }
}

pub fn visit_where_bound_predicate<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast WhereBoundPredicate) {
    if let Some(ref it) = _i . bound_lifetimes { _visitor.visit_bound_lifetimes(it) };
    _visitor.visit_type(& _i . bounded_ty);
    tokens_helper(_visitor, &(& _i . colon_token).0);
    for el in & _i . bounds { let it = el.item(); _visitor.visit_type_param_bound(it) };
}

pub fn visit_where_clause<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast WhereClause) {
    tokens_helper(_visitor, &(& _i . where_token).0);
    for el in & _i . predicates { let it = el.item(); _visitor.visit_where_predicate(it) };
}

pub fn visit_where_eq_predicate<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast WhereEqPredicate) {
    _visitor.visit_type(& _i . lhs_ty);
    tokens_helper(_visitor, &(& _i . eq_token).0);
    _visitor.visit_type(& _i . rhs_ty);
}

pub fn visit_where_predicate<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast WherePredicate) {
    use ::WherePredicate::*;
    match *_i {
        BoundPredicate(ref _binding_0, ) => {
            _visitor.visit_where_bound_predicate(_binding_0);
        }
        RegionPredicate(ref _binding_0, ) => {
            _visitor.visit_where_region_predicate(_binding_0);
        }
        EqPredicate(ref _binding_0, ) => {
            _visitor.visit_where_eq_predicate(_binding_0);
        }
    }
}

pub fn visit_where_region_predicate<'ast, V: Visitor<'ast> + ?Sized>(_visitor: &mut V, _i: &'ast WhereRegionPredicate) {
    _visitor.visit_lifetime(& _i . lifetime);
    if let Some(ref it) = _i . colon_token { tokens_helper(_visitor, &(it).0) };
    for el in & _i . bounds { let it = el.item(); _visitor.visit_lifetime(it) };
}

