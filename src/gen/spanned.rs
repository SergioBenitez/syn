// THIS FILE IS AUTOMATICALLY GENERATED; DO NOT EDIT

#![cfg_attr(rustfmt, rustfmt_skip)]
#![cfg_attr(feature = "cargo-clippy", allow(match_same_arms))]

use visit::Visitor;

pub trait Spanned {
    /// Returns the `proc_macro::Span` of this item if it can be retrieved. When
    /// using the `Span` for error reporting, it is safe to `unwrap()` it.
    ///
    /// This method is only available when the `unstable` feature is enabled.
    fn span(&self) -> Option<::proc_macro::Span>;
}

#[derive(Default)]
struct SpanVisitor {
    span: Option<::proc_macro::Span>,
}

impl<'a> Visitor<'a> for SpanVisitor {
    fn visit_span(&mut self, span: &'a ::proc_macro2::Span) {
        let span = span.into_inner();
        self.span = self.span.map_or(Some(span), |s| s.join(span));
    }
}

impl Spanned for ::Abi {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_abi(self);
        visitor.span
    }
}


impl Spanned for ::AbiKind {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_abi_kind(self);
        visitor.span
    }
}


impl Spanned for ::AngleBracketedGenericArguments {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_angle_bracketed_generic_arguments(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ArgCaptured {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_arg_captured(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ArgSelf {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_arg_self(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ArgSelfRef {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_arg_self_ref(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::Arm {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_arm(self);
        visitor.span
    }
}


impl Spanned for ::AttrStyle {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_attr_style(self);
        visitor.span
    }
}


impl Spanned for ::Attribute {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_attribute(self);
        visitor.span
    }
}


impl Spanned for ::BareFnArg {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_bare_fn_arg(self);
        visitor.span
    }
}


impl Spanned for ::BareFnArgName {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_bare_fn_arg_name(self);
        visitor.span
    }
}


impl Spanned for ::BareFnType {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_bare_fn_type(self);
        visitor.span
    }
}


impl Spanned for ::BinOp {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_bin_op(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::BindingMode {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_binding_mode(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::Block {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_block(self);
        visitor.span
    }
}


impl Spanned for ::Body {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_body(self);
        visitor.span
    }
}


impl Spanned for ::BodyEnum {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_body_enum(self);
        visitor.span
    }
}


impl Spanned for ::BodyStruct {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_body_struct(self);
        visitor.span
    }
}


impl Spanned for ::BoundLifetimes {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_bound_lifetimes(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::CaptureBy {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_capture_by(self);
        visitor.span
    }
}


impl Spanned for ::ConstParam {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_const_param(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::Constness {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_constness(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::Defaultness {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_defaultness(self);
        visitor.span
    }
}


impl Spanned for ::DeriveInput {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_derive_input(self);
        visitor.span
    }
}


impl Spanned for ::Expr {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprAddrOf {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_addr_of(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprArray {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_array(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprAssign {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_assign(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprAssignOp {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_assign_op(self);
        visitor.span
    }
}


impl Spanned for ::ExprBinary {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_binary(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprBlock {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_block(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprBox {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_box(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprBreak {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_break(self);
        visitor.span
    }
}


impl Spanned for ::ExprCall {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_call(self);
        visitor.span
    }
}


impl Spanned for ::ExprCast {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_cast(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprCatch {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_catch(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprClosure {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_closure(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprContinue {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_continue(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprField {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_field(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprForLoop {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_for_loop(self);
        visitor.span
    }
}


impl Spanned for ::ExprGroup {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_group(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprIf {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_if(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprIfLet {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_if_let(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprInPlace {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_in_place(self);
        visitor.span
    }
}


impl Spanned for ::ExprIndex {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_index(self);
        visitor.span
    }
}


impl Spanned for ::ExprKind {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_kind(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprLoop {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_loop(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprMatch {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_match(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprMethodCall {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_method_call(self);
        visitor.span
    }
}


impl Spanned for ::ExprParen {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_paren(self);
        visitor.span
    }
}


impl Spanned for ::ExprPath {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_path(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprRange {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_range(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprRepeat {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_repeat(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprRet {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_ret(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprStruct {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_struct(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprTry {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_try(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprTuple {
    fn span(&self) -> Option<::proc_macro::Span> {
        // This way manually editted. It turns out that the visitor doesn't
        // actually visit `Span`s correctly. For instance, the `Span` in
        // `self.paren_token` is never visited.
        Some(self.paren_token.0.into_inner())
    }
}


impl Spanned for ::ExprType {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_type(self);
        visitor.span
    }
}


impl Spanned for ::ExprUnary {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_unary(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprUnsafe {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_unsafe(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprWhile {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_while(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprWhileLet {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_while_let(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ExprYield {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_expr_yield(self);
        visitor.span
    }
}


impl Spanned for ::Field {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_field(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::FieldPat {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_field_pat(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::FieldValue {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_field_value(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::File {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_file(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::FnArg {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_fn_arg(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::FnDecl {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_fn_decl(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ForeignItem {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_foreign_item(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ForeignItemFn {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_foreign_item_fn(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ForeignItemStatic {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_foreign_item_static(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ForeignItemType {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_foreign_item_type(self);
        visitor.span
    }
}


impl Spanned for ::GenericArgument {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_generic_argument(self);
        visitor.span
    }
}


impl Spanned for ::GenericParam {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_generic_param(self);
        visitor.span
    }
}


impl Spanned for ::Generics {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_generics(self);
        visitor.span
    }
}


impl Spanned for ::Ident {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_ident(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ImplItem {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_impl_item(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ImplItemConst {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_impl_item_const(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ImplItemMacro {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_impl_item_macro(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ImplItemMethod {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_impl_item_method(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ImplItemType {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_impl_item_type(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ImplPolarity {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_impl_polarity(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::InPlaceKind {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_in_place_kind(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::Index {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_index(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::Item {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemConst {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_const(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemDefaultImpl {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_default_impl(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemEnum {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_enum(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemExternCrate {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_extern_crate(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemFn {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_fn(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemForeignMod {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_foreign_mod(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemImpl {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_impl(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemMacro {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_macro(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemMacro2 {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_macro2(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemMod {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_mod(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemStatic {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_static(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemStruct {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_struct(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemTrait {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_trait(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemType {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_type(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemUnion {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_union(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::ItemUse {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_item_use(self);
        visitor.span
    }
}


impl Spanned for ::LifetimeDef {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_lifetime_def(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::Local {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_local(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::MacStmtStyle {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_mac_stmt_style(self);
        visitor.span
    }
}


impl Spanned for ::Macro {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_macro(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::Member {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_member(self);
        visitor.span
    }
}


impl Spanned for ::MetaItem {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_meta_item(self);
        visitor.span
    }
}


impl Spanned for ::MetaItemList {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_meta_item_list(self);
        visitor.span
    }
}


impl Spanned for ::MetaNameValue {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_meta_name_value(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::MethodSig {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_method_sig(self);
        visitor.span
    }
}


impl Spanned for ::MutType {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_mut_type(self);
        visitor.span
    }
}


impl Spanned for ::Mutability {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_mutability(self);
        visitor.span
    }
}


impl Spanned for ::NestedMetaItem {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_nested_meta_item(self);
        visitor.span
    }
}


impl Spanned for ::ParenthesizedGenericArguments {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_parenthesized_generic_arguments(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::Pat {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_pat(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::PatBox {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_pat_box(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::PatIdent {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_pat_ident(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::PatLit {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_pat_lit(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::PatPath {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_pat_path(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::PatRange {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_pat_range(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::PatRef {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_pat_ref(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::PatSlice {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_pat_slice(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::PatStruct {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_pat_struct(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::PatTuple {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_pat_tuple(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::PatTupleStruct {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_pat_tuple_struct(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::PatWild {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_pat_wild(self);
        visitor.span
    }
}


impl Spanned for ::Path {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_path(self);
        visitor.span
    }
}


impl Spanned for ::PathArguments {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_path_arguments(self);
        visitor.span
    }
}


impl Spanned for ::PathSegment {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_path_segment(self);
        visitor.span
    }
}


impl Spanned for ::PolyTraitRef {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_poly_trait_ref(self);
        visitor.span
    }
}


impl Spanned for ::QSelf {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_qself(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::RangeLimits {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_range_limits(self);
        visitor.span
    }
}


impl Spanned for ::ReturnType {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_return_type(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::Stmt {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_stmt(self);
        visitor.span
    }
}


impl Spanned for ::TraitBoundModifier {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_trait_bound_modifier(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::TraitItem {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_trait_item(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::TraitItemConst {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_trait_item_const(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::TraitItemMacro {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_trait_item_macro(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::TraitItemMethod {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_trait_item_method(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::TraitItemType {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_trait_item_type(self);
        visitor.span
    }
}


impl Spanned for ::Type {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type(self);
        visitor.span
    }
}


impl Spanned for ::TypeArray {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_array(self);
        visitor.span
    }
}


impl Spanned for ::TypeBareFn {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_bare_fn(self);
        visitor.span
    }
}


impl Spanned for ::TypeBinding {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_binding(self);
        visitor.span
    }
}


impl Spanned for ::TypeGroup {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_group(self);
        visitor.span
    }
}


impl Spanned for ::TypeImplTrait {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_impl_trait(self);
        visitor.span
    }
}


impl Spanned for ::TypeInfer {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_infer(self);
        visitor.span
    }
}


impl Spanned for ::TypeNever {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_never(self);
        visitor.span
    }
}


impl Spanned for ::TypeParam {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_param(self);
        visitor.span
    }
}


impl Spanned for ::TypeParamBound {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_param_bound(self);
        visitor.span
    }
}


impl Spanned for ::TypeParen {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_paren(self);
        visitor.span
    }
}


impl Spanned for ::TypePath {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_path(self);
        visitor.span
    }
}


impl Spanned for ::TypePtr {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_ptr(self);
        visitor.span
    }
}


impl Spanned for ::TypeReference {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_reference(self);
        visitor.span
    }
}


impl Spanned for ::TypeSlice {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_slice(self);
        visitor.span
    }
}


impl Spanned for ::TypeTraitObject {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_trait_object(self);
        visitor.span
    }
}


impl Spanned for ::TypeTuple {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_type_tuple(self);
        visitor.span
    }
}


impl Spanned for ::UnOp {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_un_op(self);
        visitor.span
    }
}


impl Spanned for ::Unsafety {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_unsafety(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::UseGlob {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_use_glob(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::UseList {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_use_list(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::UsePath {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_use_path(self);
        visitor.span
    }
}

# [ cfg ( feature = "full" ) ]
impl Spanned for ::UseTree {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_use_tree(self);
        visitor.span
    }
}


impl Spanned for ::Variant {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_variant(self);
        visitor.span
    }
}


impl Spanned for ::VariantData {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_variant_data(self);
        visitor.span
    }
}


impl Spanned for ::VisCrate {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_vis_crate(self);
        visitor.span
    }
}


impl Spanned for ::VisInherited {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_vis_inherited(self);
        visitor.span
    }
}


impl Spanned for ::VisPublic {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_vis_public(self);
        visitor.span
    }
}


impl Spanned for ::VisRestricted {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_vis_restricted(self);
        visitor.span
    }
}


impl Spanned for ::Visibility {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_visibility(self);
        visitor.span
    }
}


impl Spanned for ::WhereBoundPredicate {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_where_bound_predicate(self);
        visitor.span
    }
}


impl Spanned for ::WhereClause {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_where_clause(self);
        visitor.span
    }
}


impl Spanned for ::WhereEqPredicate {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_where_eq_predicate(self);
        visitor.span
    }
}


impl Spanned for ::WherePredicate {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_where_predicate(self);
        visitor.span
    }
}


impl Spanned for ::WhereRegionPredicate {
    fn span(&self) -> Option<::proc_macro::Span> {
        let mut visitor = SpanVisitor::default();
        visitor.visit_where_region_predicate(self);
        visitor.span
    }
}


